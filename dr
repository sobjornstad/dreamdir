#!/bin/bash
# shellcheck disable=2086
# shellcheck disable=2001

# %%% dr - Dreamdir utility program
# Copyright (c) 2015-2016 Soren Bjornstad; see LICENSE for details.

##### NOTES ON SHELLCHECK DIRECTIVES #####
# (For some stupid reason there can't be other comments between the shebang and
# the disable directives.)
# 2086: Turn off checks for variable quoting.
#   It's really too bad this has to be turned off, because it catches places
#   where variables really should have been quoted but were not. Unfortunately,
#   it flags passing around command-line arguments and lists of files like
#   "grep 'pattern' $dreamGlob" as errors, and as such produces a heap of
#   irrelevant warnings in this script.
# 2001: Turn off checks for using 'sed' instead of shell internal replacement.
#   All the situations it flagged were either too complicated or weren't a good
#   choice for some other reason.


##### CONSTANTS #####
# application version
MYVERSION="1.0.3"

# matching pattern for dream files
dreamGlob='[0-9][0-9][0-9][0-9][0-9].dre'


##### DOCUMENTATION / HELP MESSAGES #####
# usagemsg()
# Print the usage/help message and exit.
usagemsg() {
    cat <<USAGEMSG
dr - Dreamdir utility program
Copyright (c) 2015-2016 Soren Bjornstad; see LICENSE for details.

Usage: $(basename "$0") <action> [<action arguments>]
There are two types of actions, searches and utilities.

                             SEARCHES
Searches display some information about a subset of dreams. They take an
implied search expression after their other arguments; an empty search
expression selects all dreams. For information about search expressions, type
'$(basename "$0") help search'.

cat [-f]            :: print all content of matching dreams on stdout; if -f,
                       pass through 'fold -s' to limit line length to 80 chars
dump-headers        :: print headers of matching dreams
edit                :: pass matching dreams as args to \$EDITOR
find                :: show numbers of matching dreams
filename-display    :: print filenames of matching dreams
get-header <header> :: print values of header for matching dreams
header-values [-f] <header> :: show a list of all values used for <header>
                       in matching dream (include frequency if -f)
list-headers [-f]   :: list headers used in at least one matching dream
                       (with frequency if -f specified)
word-count          :: show word count of the specified dreams, not
                       including headers
winnow              :: read filenames from stdin and AND them with
                       the results of another query
xwinnow             :: read filenames from stdin and XOR them with
                       the results of another query

                             UTILITIES
Utilities perform some other action.

help                :: show this usage message
header-replace      :: regex search-and-replace on headers; type
                       '$(basename "$0") help header-replace' for info
last-lucid          :: edit the dream with the highest number that
                       has a Lucid header
new                 :: create a new dream with the next available ID
                       number and open it for editing
regenerate-graphs   :: run scripts/RegeneratePlots.sh to make graphs
stats               :: display dream statistics
check-validity      :: format sanity check: ensure all dreams have
                       IDs and dates and ID numbers are contiguous
version             :: print version number of this 'dr'

An action can be abbreviated by its initials (e.g., help: h, list-headers: lh).
USAGEMSG
    exit 0
}

# usagemsg_edit()
# Print the help on searching and exit.
usagemsg_edit() {
    cat <<USAGEMSG
                             DR - SEARCHING
$(basename "$0") <action> [<options>] <expr>

Select dreams matching search expression <expr> and take <action>
(available search actions are listed under 'dr help').

                             SEARCH EXPRESSIONS
A search expression is one or more of the following. If multiple search
expressions are given, their results will be concatenated.
  * a dream number (leading zeroes are allowed but not required)
  * a range of numbers: 12-18 or -18 (i.e., 1-18) or 12- (i.e., 12-last dream);
    leading zeroes are allowed but not required
  * a Bash globbing pattern for some dream numbers (leading zeroes are required)
  * a[ll]          :: select all dreams (same as a quoted '*')
  * b[ack] [<N>]   :: select the dream N positions from the end, inclusive
  * l[ast] [<N>]   :: like 'back', but select all dreams between N and the end
  * g[rep] <regex> :: select all dreams matching ERE <regex> anywhere in the
                      file (whether in headers, notes, or text)
  * t[agged] <header> <hregex> :: select dreams with <header> matching <hregex>
  * r[andom] [<N>] :: select N dreams randomly from your dreamdir, in numerical
                      order (add -s if desired)

N defaults to 1 if not provided.

A search expression may be entirely blank; in this case all dreams are
selected. Options are still parsed (see below).

Globbing patterns used in search expressions should be quoted (e.g., to edit
all dreams, use "dr edit '*'" , not "dr edit *").  They will be expanded either
way, but 'dr' can parse a glob more quickly than a very long argument list, so
the search will finish faster if you quote the pattern.  Note also that
including '.dre' is optional -- that is, '0100[34]' expands to '01003.dre
01004.dre'.

                             HREGEXES
<hregex>es are Extended Regular Expressions (EREs) that match only within
comma-separated items.  The ^ and $ anchors can be used to match the start and
end of a single item.  For example, with header "Tags: foo, bar baz, foobar":
  REGEX     :: MATCHES
  foo       :: 'foo' & 'foobar'
  bar       :: 'bar' & 'foobar'
  baz       :: 'bar baz'
  az        :: 'bar baz'
  .*baz     :: 'bar baz'
  ^ba.*az   :: 'bar baz'
  ^foobar$  :: 'foobar'
  ^baz$     :: -
  o, ba     :: -
  foo.*baz  :: -
Padding your expression with ^ and $ is often useful; otherwise 'cat' matches
'catalog' and 'duplicate'. If you want to avoid 'catalog' but still get 'cat
food', you can pad with '\\b' (word boundary).

With 'dr find tagged', a dream matches if any comma-separated item matches
the hregex.

With 'dr header-replace', only the specific comma-separated item that matches
is replaced.

                             OPTIONS
The following options may be used with any search expression. They are applied
to the results in this order if several are used:
  -v     :: invert match (show only dreams that do *not* match expression)
  -r     :: reverse the order of returned results
  -s     :: randomize (shuffle) the order of returned results
  -l <N> :: show only the first N results (if N is negative, remove N results
            from the end of the list)

                             EXAMPLES
dr edit 50                    :: edit dream number 50
dr filename-display 006[12]?  :: show the filenames of dreams #610-629
dr edit last 4 890            :: edit the last four dreams and #890
dr dump-headers 20 0[12]01*   :: show headers for dreams #20, #1010-1019,
                                 #2010-2019
dr get-header Tags '*'        :: get a listing of the tags of all your dreams
dr edit -s last 6             :: edit the last six dreams in a random order
dr cat -l 6 grep 'foo|bar'    :: print the first six dreams with a line
                                 containing the substring "foo" or "bar"
dr edit -r grep 'XX' back 20  :: edit the dream 20 from the end, then dreams
                                 containing "XX" in reverse numerical order
dr filename-display random 5  :: list the filenames of five random dreams
dr find tagged People Maud    :: edit dreams in which Maud appeared
dr edit tagged Tags '^cat$'   :: display dreams tagged with 'cat', but not
                                 'caterwaul' or 'dedicate'
dr fd 006[12]? |              :: display filenames for dreams #610-629 that
  dr winnow tagged Tags 'dog'    also have a tag containing 'dog'
dr fd t Tags '^cat$' |        :: show dreams that are not tagged exactly 'cat'
  dr xwinnow grep '\\bcat\\b'      but do use the word 'cat' somewhere else
dr wc                         :: display a word count of all dreams
dr wc -sl 12 all              :: display a word count of 12 random dreams
USAGEMSG
    exit 0
}

usagemsg_header_replace() {
    cat <<USAGEMSG
                             DR - HEADER-REPLACE
$(basename "$0") header-replace [-f] <header> <find> <replace> <search-expr>

In dreams matching <search-expr>, replace instances of <find> in header
<header> with <replace>.  <header> and <replace> are EREs; <find> is
specifically an hregex (see 'help dr search' for more information).

<find> will not match across commas, but it may match and change several tags
separately.  For example, for the header 'Tags: bar, baz', we could find 'ba'
and replace with 'fo' and obtain 'Tags: for, foz', but a search for 'r, b' will
not match anything.

Each comma-separated value is considered a separate line, so we can search for
'^foobar$' to match only the entire tag 'foobar' and not, say, 'foobarbaz'.

                             PREVIEWING
Without the -f option, dr produces a preview of the changes your search-and-
replace will make.  Typical output looks like this:

    $ dr header-replace Tags "foo" "quux"
                    === Preview of changes to be applied ===
    01223.dre:
      -foo
      +quux
      =Tags:	quux, bar, baz

    Changes will affect 1 file.
    To make these changes, rerun the command with the '-f' option.

One section will be produced for each dream affected.  The first lines
underneath are a diff between the two sets of values.  The last line shows the
new header line that will be substituted in if you accept the changes.

                             RUNNING
After checking over the preview, rerun the command with the -f option to
actually make the changes.  Naturally, this can be quite dangerous with the
wrong regexes (e.g., a replacement of '.' with 'x' will completely trash all
your headers), so it's wise to make a backup first.  You'll also be required to
confirm interactively that you've double-checked the preview.

(NOTE: If the replace command gets interrupted in the middle, it is possible,
though very unlikely, that one of your dreams will have been deleted; you can
check this by seeing if 'dr check-validity' fails with a missing ID number.  If
this does occur you will find the content in the file 'repl.tmp' in your
dreamdir.)
USAGEMSG
}


##### UTILITY FUNCTIONS #####
# ensure()
# Make sure a condition necessary for script execution is true.
#
# Arguments:
#     $1 - an argument to `test`
#     $2 - a message to display if the test fails
#     $3 - (optional, default 1) exit status to return if the test fails
# State change & return:
#     If the test evaluates non-zero, the script prints $2 and exits with
#     status $3 (or 1). Else, control returns to the caller.
ensure() {
    eval "test $1"
    if [ $? -ne 0 ]
    then
        if [ -z "$3" ]; then
            local exitval=1
        else
            local exitval=$3
        fi
        echo -e "$2"
        exit "$exitval"
    else
        return 0
    fi
}

# die()
# Unconditionally exit the shell with status 1 after printing the given error.
#
# Arguments:
#     $1 - Message to complain with.
die() {
    echo -e "$1"
    exit 1
}

# Don't display the directory stack on push/pop.
# shellcheck disable=2120
# :: no arguments ever used - we could want them later
pushd () {
    command pushd "$@" > /dev/null
}
# shellcheck disable=2120
popd () {
    command popd "$@" > /dev/null
}

# numerize()
# Display some string in singular or plural as appropriate.
#
# Arguments:
# $1 - the number to condition the singular/plural status on
# $2 - the singular form
# $3 - the plural form (optional; if not provided, defaults to singular + 's')
#
# Example:
# $ echo "I think there $(numerize $n "is" "are") $n $(numerize $n "foo") here."
# I think there is 1 foo here.
# I think there are 2 foos here.
numerize() {
    ensure "! -z \"$1\"" "Invalid arguments given to numerize()"
    ensure "! -z \"$2\"" "Invalid arguments given to numerize()"
    local num=$1
    local singular=$2
    if [ -z "$3" ]; then
        local plural="$singular"s
    else
        local plural=$3
    fi

    if [ "$num" -ne 1 ]; then
        echo "$plural"
    else
        echo "$singular"
    fi
}

# defileify()
# Given some dream filenames, convert them to comma-separated numbers, with no
# leading zeroes, and print the result.
#
# Arguments:
# (variable number) - the files to process
defileify() {
    echo "$@" | sed -e 's/\(^\| \)00*/\1/g' | sed -e 's/\.dre/,/g' | sed -e 's/,$//'
}

# colorify()
# Given a string, print the string with "syntax highlighting" for dreamdir
# syntax.
#
# Argument:
# $1 - the string to color

COL_HEADERS=$(tput setaf 2)
COL_LUCID=$(tput setaf 4)
COL_NOTES=$(tput setaf 6)
COL_VERBATIM=$(tput setaf 1)
COL_CLEAR=$(tput sgr0)

colorify() {
    # escape quotes and newlines so we can plop this into a Python string
	local txt
	txt=$(echo "$1" | sed -e 's/"/\\"/g' | perl -pe 's/\n/\\n/g')
	python2 <<-END
	# -*- coding: utf-8 -*-
	from scripts.ddirparse import strHighlight
	colors = {'headers': '$COL_HEADERS', 'lucid': '$COL_LUCID',
	          'notes': '$COL_NOTES', 'verbatim': '$COL_VERBATIM',
	          'clear': '$COL_CLEAR'}
	# we use rstrip to remove the trailing newline since that's what Bash would
	# do if we just printed it outright
	print strHighlight("$txt", colors).rstrip()
	END
}

# getrange()
# Given a range of dreams in the form Range ::= Number{*}@Number{*}, print
# a string of the filenames of dreams in that range (inclusive). If one of the
# numbers is missing, the first or last dream in the dreamdir is implied; '@'
# as a range is equivalent to all dreams.
#
# The @ will probably be input as something more sensible like '-'; we just use
# it as an internal separator because it doesn't conflict with command-line
# options.
#
# Called in several places in dreamfind().
#
# Argument:
# $1 - the range to find
#
# Example:
# $ echo "Filename list: $(getrange 4-8)"
# 00004.dre 00005.dre 00006.dre 00007.dre 00008.dre
getrange() {
    ensure "! -z \"$1\"" "Invalid arguments given to getrange()"
    local startat; local endat
    startat=$(echo "$1" | cut -d '@' -f 1)
    endat=$(echo "$1" | cut -d '@' -f 2)
    if [ -z "$startat" ]; then
        dreamfind 1
        startat=$(defileify $args)
    fi
    if [ -z "$endat" ]; then
        dreamfind last
        endat=$(defileify $args)
    fi
    ensure "! -z \"$startat\"" "No results."
    ensure "! -z \"$endat\"" "No results."
    seq -f '%05g.dre' "$startat" "$endat"
}


##### COMPLICATED ROUTINES #####
# dreamfind()
# Parse a search expression. The filenames of matching dreams are placed in the
# variable $args.
#
# This function may be used either to parse user input or to select dreams
# matching some pattern from within the script.
#
# Arguments:
# (variable number) A search expression, as input at the command line.
dreamfind() {
    # Before parsing optional arguments, we have to change the delimiter used
    # for ranges, because getopts isn't smart enough to see that "-20" is a
    # unidirectional range from 1-20, not two arguments "2" and "0".
    # http://unix.stackexchange.com/questions/258512/how-to-remove-a-positional-parameter-from
    for arg; do
        shift
        if [[ $arg =~ ^[0-9]*-[0-9]*$ ]]; then
            newarg="${arg//-/@}"
        else
            newarg="$arg"
        fi
        set -- "$@" "$newarg"
    done

    # Parse optional arguments to edit.
    df_doReverse=0    # global because a user that has to sort the results
    df_doShuf=0       # for further processing has to reapply these filters
    local limit=0
    local invert=0
    OPTIND=0  # if loop doesn't run at all, we need to make sure it's reset
    while getopts rsl:v opt; do
        case $opt in
        r)
            df_doReverse=1 ;;
        s)
            df_doShuf=1 ;;
        l)
            limit="$OPTARG"
            [[ $limit =~ ^[0-9]+$ ]] || die "'$limit' is not a valid number of dreams to limit your search to."
            ;;
        v)
            invert=1 ;;
        esac
    done
    shift $((OPTIND-1))

    # No arguments is equivalent to "all".
    if [ -z "$1" ]; then
        # http://stackoverflow.com/questions/13762370/
        # assigning-to-a-positional-parameter
        set -- "all"
    fi

    # Now compile a list of all the dreams we've specified.
    args=""
    local newargs=""
    local howMany=0
    while [ ! -z "$1" ]
    do
        if [[ $1 =~ ^[0-9][0-9]*$ ]]; then
            let local num=10#$1  # in case user uses leading zeroes
            printf -v newargs '%05d.dre' "$num"
        elif [[ $1 =~ ^[0-9]*@[0-9]*$ ]]; then
            newargs=$(getrange "$1")
        else case "$1" in
        "last"|"back"|"l"|"b")
            local action=$1
            if [[ ! -z "$2" && $2 =~ ^[0-9]+$ ]]; then
                howMany="$2"
                shift
            else
                howMany=1
            fi
            newargs=$(find $dreamGlob | tail -n "$howMany")
            if [[ "$action" == "back" || "$action" == "b" ]]; then
                newargs=$(echo "$newargs" | head -n 1)
            fi
            ;;
        
        "grep"|"g")
            ensure "! -z \"$2\"" "'grep' needs a pattern. (See 'dr help search' for help.)"
            newargs=$(grep -El "$2" $dreamGlob)
            shift
            ;;

        "random"|"r")
            if [[ ! -z "$2" && $2 =~ ^[0-9]+$ ]]; then
                howMany=$2
                shift
            else
                howMany=1
            fi
            newargs=$(find $dreamGlob | shuf | head -n "$howMany" | sort)
            ;;

        "all"|"a")
            newargs=$dreamGlob
            ;;

        "tagged"|"t")
            local usage="Usage: dr $action tagged <header regex> <value regex>"
            ensure "! -z \"$2\"" "$usage"
            ensure "! -z \"$3\"" "$usage"
            # The idea here is to replace the delimiters with '@@@@@' (which we
            # can fairly safely assume will not show up in a tag), then change
            # the user's regex to match '@@@@@' as BOL/EOL and not cross it
            # with '.'.
            local header="$2"
            local pattern
            pattern=$(echo "$3" | sed -e 's/[$^]/@@@@@/' | sed -e 's/\$/[$@]/' | sed -e 's/\./[^@]/')
            newargs=$(grep -m 1 "$header:	" $dreamGlob | sed -e "s/$header:	/@@@@@/" | sed -e 's/, /@@@@@/g' | sed -e 's/$/@@@@@/' | grep -E "$pattern" | sed -e 's/\([0-9]\{5\}\.dre\):.*/\1/')
            shift; shift
            ;;

        *) # filename glob
            if echo "$1" | grep -q ".dre"; then
                newargs="$1"
            else
                newargs="$1.dre"
            fi
        esac
        fi  # regex matches

        # Add args parsed to the complete list and proceed. Note that if a type
        # of expression has arguments, it's responsible for shifting those away
        # before it finishes.
        args="$args $newargs"
        shift
    done

    # apply option flags
    # shellcheck disable=2086
    # :: We *don't* want $args to be quoted -- we're doing this to expand globs.
    args=$(echo $args | cat -)
    if [ $invert -eq 1 ]; then
        args=$(comm -3 <(find $dreamGlob | tr ' ' '\n' | sort) <(echo "$args" | tr ' ' '\n' | sort))
    fi
    [ $df_doReverse -eq 1 ] && args=$(echo "$args" | tr ' ' '\n' | tac)
    [ $df_doShuf -eq 1 ]    && args=$(echo "$args" | tr ' ' '\n' | shuf)
    [ $limit -ne 0 ]        && args=$(echo "$args" | tr ' ' '\n' | head -n $limit)

    # sanity check
    [ -z "$args" ] && die "No results."
    for i in $args
    do
        ensure "-f \"$i\"" "Matched nonexistent file '$i'; please check your search terms and try again.\n(Type 'dr help search' for help.)"
    done
}

# validate_dreamdir()
# Check to see if our dreamdir's format is okay. Extracted from the main case
# statement purely because it's long and makes the script harder to read.
validate_dreamdir() {
    # set up temp file for checking id and date headers
    local tempfile="/tmp/dreamgrep" # contains list of dream files
    ensure "! -e $tempfile" "Please check & remove existing temp file $tempfile and try again."
    find $dreamGlob | sort > "$tempfile"

    # check for id problems
    local checkFailedFor
    checkFailedFor=$(grep -l 'Id:	[0-9]\{5\}' $dreamGlob | sort | diff - "$tempfile")
    if [ $? == 0 ]; then
        echo "ID value check...OK"
    else
        echo "ID value check...FAIL"
        echo "The files listed in the following diff have missing or incomplete"
        echo "Id headers:"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi

    # check for date problems (similar -- consider a function)
    checkFailedFor=$(grep -l 'Date:	[12][901][0-9]\{2\}-[01][0-9]-[0123][0-9]' $dreamGlob | sort | diff - "$tempfile")
    if [ $? == 0 ]; then
        echo "Date check...OK"
    else
        echo "Date check...FAIL"
        echo "The files listed in the following diff have missing or invalid"
        echo "Date headers, or represent implausible or impossible dates."
        echo "(Note: dates must be in YYYY-MM-DD format.)"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi
    rm "$tempfile"

    # check for ID continuity
    # works with Python 2 & 3 -- check dual compatibility after changes
    python <<PYTH_ID_CHECK
import os, sys
listing = sorted(os.listdir('.'))
listing = filter(lambda i: i.endswith('.dre'), listing)
nums = []
for i in listing:
    try:
        nums.append(int(i))
    except ValueError:
        # not a dream file, but auxiliary of some kind
        continue

lastnum = 0
for i in nums:
    if i != lastnum+1:
        print("ID continuity check...FAIL")
        print("Failure was on ID %i, not continuous with previous ID %i." % (
              i, lastnum))
        sys.exit(1)
    else:
        lastnum = i
print("ID continuity check...OK")
sys.exit(0)
PYTH_ID_CHECK
    if [ $? != 0 ]; then
        exit 1
    fi

    echo "All tests succeeded."
}

# stats_display()
# Calculate and display textual statistics.
stats_display() {
    echo "Crunching the latest numbers for you, just a moment..."
    local colOn='[1;34m'
    local colOff='[0m'

    local today; local filenamesToday
    today=$(date '+%Y-%m-%d')
    filenamesToday=$(grep -l "Date:	$today" $dreamGlob)
    if [ ! -z "$filenamesToday" ]; then
        local dreamsToday; local numDreamsToday; local dreamsTodayDisp
        local lucidsToday; local wordCountToday
        dreamsToday=$(echo "$filenamesToday" | sed -e 's/\.dre'//g | sed -e 's/ 0*/ /g' | sed -e 's/^0*//') # NOT very clean.
        numDreamsToday=$(echo "$dreamsToday" | wc -w)
        dreamsTodayDisp=$(echo $dreamsToday | sed -e 's/ /, /g')
        # shellcheck disable=2126
        # :: not an appropriate usage of 'grep -c'
        lucidsToday=$(grep 'Lucid:	' $filenamesToday | wc -l)
        wordCountToday=$(wc -w $filenamesToday | tail -n 1 | sed -e 's/^ *//' | cut -d ' ' -f 1)
        if [ -f "$wordCountToday" ]; then
            # there was only one dream and no "total" line, so we pulled out the wrong thing
            wordCountToday=$(wc -w $filenamesToday | cut -d ' ' -f 1)
        fi
    fi

    local numDreams; local wordCount; local avgWordCount; local dateStats
    numDreams=$(find $dreamGlob | wc -l)
    wordCount=$(wc $dreamGlob -w | tail -n 1 | cut -d ' ' -f 2)
    avgWordCount=$((wordCount / numDreams))
    dateStats=$(python2 <<PYTH_DATEFREQ
# OUTPUT FORMAT:
# <number of dates recorded> <earliest date> <latest date> <date with most dreams> <how many that was>
import scripts.ddirparse as dp
dp.setDreamdir("$PWD")
dateattrs = dp.getAttribForAllDreams('Date')
dates = [i.split('\t')[1] for i in dateattrs.values()]
freqs = {}
for date in dates:
    freqs[date] = freqs.get(date, 0) + 1
keyList = freqs.keys()
print len(keyList),
print min(keyList),
print max(keyList),
# create list of keys sorted by the order of their values, min to max
byFreq = sorted(keyList, cmp=lambda a,b: cmp(freqs[a],freqs[b]))
print byFreq[-1],       # most number of dreams
print freqs[byFreq[-1]] # how many?
PYTH_DATEFREQ
)
    local mostWordsDay
    mostWordsDay=$(python2 <<PYTH_MOSTWORDS
# Getting acceptable performance here requires unfolding some possible
# functions and abstractions into this (nevertheless simple enough) loop.
# TODO: This should be a function in scripts.ddirparse, I can think of tons of
# other good things to do with this, like graphing and printing a table.
import scripts.ddirparse as dp
dp.setDreamdir("$PWD")
wcs = {}
for f in dp.allDreamfiles():
    date = None
    counting = False
    for line in f:
        textline = line.strip()
        if counting:
            wcs[date] += len(textline.split())
        else:
            if textline.startswith('Date:\t'):
                date = textline.split(':\t')[1].strip()
            elif not textline:
                # end of headers, start counter
                counting = True
                if date not in wcs:
                    wcs[date] = 0
# create list of keys sorted by the order of their values, max to min
wcOrder = sorted(wcs.keys(), cmp=lambda a,b: cmp(wcs[b],wcs[a]))
print wcOrder[0], wcs[wcOrder[0]], # # of dreams, date of it
print len(dp.getDreamsTagged('Date', wcOrder[0])) # how many dreams
PYTH_MOSTWORDS
)
    local datesRecorded; local avgDreamsPerDay; local avgWordCountDay
    local earliestDate; local latestDate; local mostDreamsDate; local numMostDreams
    datesRecorded=$(echo "$dateStats" | cut -d ' ' -f 1)
    avgDreamsPerDay=$(echo "scale=2; $numDreams / $datesRecorded" | bc -q)
    avgWordCountDay=$(echo "$avgDreamsPerDay * $avgWordCount" | bc -q)
    earliestDate=$(echo "$dateStats" | cut -d ' ' -f 2)
    latestDate=$(echo "$dateStats" | cut -d ' ' -f 3)
    mostDreamsDate=$(echo "$dateStats" | cut -d ' ' -f 4)
    numMostDreams=$(echo "$dateStats" | cut -d ' ' -f 5)

    local mostWordsOnDay; local mostWords; local dreamsInMostWordsDay
    local mostWordsDream; local mostWordsDreamNum; local mostWordsDreamCount
    mostWordsOnDay=$(echo "$mostWordsDay" | cut -d ' ' -f 1)
    mostWords=$(echo "$mostWordsDay" | cut -d ' ' -f 2)
    dreamsInMostWordsDay=$(echo "$mostWordsDay" | cut -d ' ' -f 3)
    mostWordsDream=$(wc -w $dreamGlob | sort -n | sed -e '$ d' | tail -n 1)
    mostWordsDreamNum=$(echo "$mostWordsDream" | sed -e 's/^ *[0-9]\+ 0*\([0-9]\+\).dre$/\1/')
    mostWordsDreamCount=$(echo "$mostWordsDream" | sed -e 's/^ *\([0-9]\+\).*/\1/')

    local lucidFilenames; local numLucids; local percentLucid
    local totalLucidWordCount; local avgLucidWordCount; local percentLucidWordCount
    local daysRecordedLds; local percentDaysRecordedLds
    lucidFilenames=$(grep -l 'Lucid:	' $dreamGlob)
    numLucids=$(echo $lucidFilenames | wc -w)
    percentLucid=$(echo "scale=2; 100 * $numLucids / $numDreams" | bc -q)
    totalLucidWordCount=$(wc -w $lucidFilenames | tail -n 1 | cut -d ' ' -f 2)
    avgLucidWordCount=$((totalLucidWordCount / numLucids))
    percentLucidWordCount=$(echo "scale=2; 100 * $totalLucidWordCount / $wordCount" | bc -q)
    daysRecordedLds=$(python2 <<PYTH_DAYS_LDS
# Output format: <days with recorded LDs>
import scripts.ddirparse as dp
dp.setDreamdir("$PWD")
lucids = dp.getDreamsTagged('Lucid', '')
allDates = dp.getAttribForAllDreams('Date')
allDates = {k: v.split('\t')[1] for k,v in allDates.iteritems()}
# Use a dictionary to make future expansion to frequency, etc., easier
lucidDays = {}
for i in lucids:
    lucidDays[allDates[i]] = lucidDays.get(allDates[i], 0) + 1
print len(lucidDays)
PYTH_DAYS_LDS
)
    percentDaysRecordedLds=$(echo "scale=2; 100 * $daysRecordedLds / $datesRecorded" | bc -q)

# Consider, inserting commas into a number:
# echo "$number" | rev | sed 's/\([0-9][0-9][0-9]\)\([0-9]\)/\1,\2/g' | rev

echo -e "${colOn}Today$colOff"
echo -e "Today: $today"
if [ -z "$filenamesToday" ]; then
    echo -e "No dreams recorded today.\n"
else
    echo -e "Dreams recorded today: $numDreamsToday ($dreamsTodayDisp)"
    echo -e "Lucid dreams recorded today: $lucidsToday"
    echo -e "Total word count today: $wordCountToday\n"
fi
cat <<STATS_DISP
${colOn}Recall and recording$colOff
Total dreams: $numDreams
Days with recorded dreams: $datesRecorded
Average dreams per recorded day: $avgDreamsPerDay
Date range: $earliestDate – $latestDate
Day with most dreams: $mostDreamsDate ($numMostDreams)
Total word count: $wordCount
Average words per dream: $avgWordCount
Day with highest word count: $mostWordsOnDay ($mostWords words over $dreamsInMostWordsDay dreams)
Single dream with highest word count: #$mostWordsDreamNum ($mostWordsDreamCount words)

${colOn}Lucidity$colOff
Total lucid dreams: $numLucids
Percentage lucid: $percentLucid%
Days with recorded LDs: $daysRecordedLds
Percentage recorded days with at least one LD: $percentDaysRecordedLds%
Total lucid word count: $totalLucidWordCount
Average words per lucid dream: $avgLucidWordCount
Percentage of words in lucid dreams: $percentLucidWordCount%

${colOn}Table summary${colOff}
		Total	Avg/Day	Max/Day	Today
# of dreams	$numDreams	$avgDreamsPerDay	$numMostDreams	$numDreamsToday
Word count	$wordCount	$avgWordCountDay	$mostWords	$wordCountToday

See also 'dr list-headers -f' and 'dr header-values -f [header]'.
STATS_DISP
}


##### MAIN SCRIPT #####
# If DREAMDIR environment variable is set and we're not already in $DREAMDIR,
# change directory into it until the end of the script.
didpush=0
# shellcheck disable=2034
# :: not using this variable now, but it's good to have it here if we need it
oldpwd="$PWD" # if we need to know where the user is running the script from
if [[ ! -z "$DREAMDIR" && "$PWD" != "$DREAMDIR" && ! -f ".dreamdir" ]]; then
    didpush=1
    pushd "$DREAMDIR"
    if [[ $? != 0 ]]; then
        echo "ERROR: The current directory is not a dreamdir and the DREAMDIR"
        echo "environment variable is set to an invalid directory"
        echo "($DREAMDIR). Exiting."
        exit 1
    fi
fi

# Confirm that we've ended up in a dreamdir.
ensure '-f .dreamdir' "Please run this script from a dreamdir, or set the environment
variable \$DREAMDIR to the path to your dreamdir."

# Figure out what action we're going to do and jump to appropriate code.
[ -z "$1" ] && usagemsg
action="$1"
shift # arguments to actions start at $1

case "$action" in
"new"|"n")
    oldUmask=$(umask)
    umask 0177 # dreams default to 600 for basic privacy
    today=$(date '+%Y-%m-%d')
    lastNum=$(find $dreamGlob | sort | tail -n 1 | cut -c 1-5)
    ensure "-f $lastNum.dre" "Unable to correctly find last dream number. Please ensure no non-dream files in the dreamdir end with '.dre'. (Pulled '$lastNum'.)"
    let newNum=10#$lastNum+1
    printf -v newNum '%05d' "$newNum"

    # http://unix.stackexchange.com/questions/88490/how-do-you-use-output-redirection-in-combination-with-here-documents-and-cat
    ed <<NEWDREAM >/dev/null 2>&1
i
Id:	$newNum
Date:	$today
Time:	
Tags:	


.
w $newNum.dre
w /tmp/$newNum.dre
q
NEWDREAM

    if [ "$EDITOR" == "vim" ]; then
        # use vim's option to place the cursor on the last line
        vim "$newNum.dre" +
    else
        "$EDITOR" "$newNum.dre"
    fi
    diff "/tmp/$newNum.dre" "$newNum.dre" > /dev/null 2>&1
    if [ $? == 0 ]; then
        echo "Deleting unmodified dream file."
        rm "$newNum.dre"
    fi
    rm "/tmp/$newNum.dre"
    umask "$oldUmask"
    ;;

"edit"|"e")
    dreamfind "$@"
    $EDITOR $args
    ;;

"find"|"f")
    dreamfind "$@"
    # remove leading zeroes and '.dre' for display, add separator commas
    results="$(defileify $args)"
    echo -e "$(echo $results | wc -w) matches: [$results]"
    ;;

"filename-display"|"fd")
    dreamfind "$@"
    echo "$args"
    ;;

"winnow"|"w"|"xwinnow"|"x")
    #TODO: Add arguments to open results in editor or change to find syntax
    if [[ "$action" == "winnow" || "$action" == "w" ]]
    then commparams="-12"
    else commparams="-3"
    fi

    read -r toFilter
    dreamfind "$@"
    results=$(comm $commparams <(echo "$toFilter" | tr ' ' '\n' | sort) <(echo "$args" | tr ' ' '\n' | sort))
    # since comm needs sorted content, we have to reapply the order changes
    [ $df_doReverse == 1 ] && results=$(echo "$results" | tac)
    [ $df_doShuf == 1 ]    && results=$(echo "$results" | shuf)
    echo "$results"
    ;;

"get-header"|"gh")
    #TODO: Possibility of formatting options (filename or number, remove
    #leading 0's, include header name)
    usageMsg="Usage: $(basename "$0") get-header <header> <search-expr>"
    ensure "! -z \"$1\"" "$usageMsg"
    ensure "! -z \"$2\"" "$usageMsg"
    getHeader=$1
    shift
    dreamfind "$@"
    grep "$getHeader:	" $args | sed -e "s/$getHeader:	\(.*\)/\1/" | sed -e 's/^00*\([0-9]\+\).dre:/\1: /'
    ;;

"dump-headers"|"dh")
    dreamfind "$@"
    for i in $args; do
        [ ! -f "$i" ] && echo "File $i not found."
        text=$(awk '{ if(!$0) exit; print $0; }' < "$i")
        if [ -t 1 ]; then
            # running in an interactive terminal
            colorify "$text"
        else
            echo "$text"
        fi
        echo ""
    done
    ;;

"cat"|"c")
    if [ "$1" == "-f" ]; then
        printCommand="fold -s"
        shift
    else
        printCommand="cat"
    fi

    dreamfind "$@"
    for i in $args; do
        text=$($printCommand "$i")
        if [ -t 1 ]; then
            # running in an interactive terminal
            colorify "$text"
        else
            echo "$text"
        fi
        echo -en "\n\n"
    done
    ;;

"list-headers"|"lh")
    if [ "$1" == "-f" ]; then
        showFreq=1
        shift
    else
        showFreq=0
    fi
    dreamfind "$@"
    results=$(grep -h '^.*:	' $args | sed -e 's/^\(.*\):	.*$/\1/' | sort)
    if [ $showFreq == 1 ]; then
        echo "$results" | uniq -c | sort -b -k 1rn -k 2
    else
        echo "$results" | uniq
    fi
    ;;

"header-values"|"hv")
    if [ "$1" == "-f" ]; then
        showfreq=1
        shift
    else
        showfreq=0
    fi
    ensure "! -z \"$1\"" \
        "Please specify a header type, like '$(basename "$0") header-values Tags'."
    header="$1"
    shift
    dreamfind "$@"

    results=$(grep "$header:	" $args | sed -e 's/.*:	//' | sed -e 's/, /\n/g' | sort)
    if [ $showfreq == 1 ]; then
        echo "$results" | uniq -c | sort -b -k 1rn -k 2
    else
        echo "$results" | uniq
    fi
    ;;

"header-replace"|"hr")
    usageMsg="Usage: $(basename "$0") header-replace [-f] <header> <search> <replace> <search-expr>\nType 'dr help header-replace' for details."
    ensure "! -z \"$1\"" "$usageMsg"
    ensure "! -z \"$2\"" "$usageMsg"
    ensure "! -z \"$3\"" "$usageMsg"
    [[ "$2" =~ "@" || "$3" =~ "@" ]] && \
        die "Sorry, at-signs (@) are not valid in search/replace regexes."

    if [ "$1" == "-f" ]; then
        doChange=1
        shift
    else
        doChange=0
    fi

    header="$1"
    searchpat="$2"
    replpat="$3"
    shift; shift; shift

    # Since the replace loop is rather expensive, compile a list of dreams that
    # both match our search-expr and include the <search> hregex, and look only
    # at those.
    dreamfind "$@"
    affectOnlyDreams="$args"
    dreamfind tagged "$header" "$searchpat"
    args=$(comm -12 <(echo "$affectOnlyDreams" | tr ' ' '\n') \
                    <(echo "$args" | tr ' ' '\n'))

    # If we're actually making changes, confirm that we really want to.
    if [ $doChange == 1 ]; then
        numToChange=$(echo "$args" | wc -w)
        echo "You are about to apply a search-and-replace that will affect" \
        "$numToChange $(numerize "$numToChange" dream)."
        if [ "$numToChange" -ge 50 ]; then
            echo -e "\e[1;31mThat looks like quite a few dreams.\e[0m"
        fi
        echo "If this doesn't sound right, please check the results without -f first!"
        read -rp "Do you wish to continue (y/n)? " doCont
        if [ "$doCont" != "y" ]; then
            exit 0
        fi
        doReplace=1
        shift
    else
        echo "                    === Preview of changes to be applied ==="
        doReplace=0
    fi

    numAffected=0
    for filename in $args
    do
        headerline=$(grep -m 1 "$header:	" "$filename")
        oldtags=$(echo "$headerline" | sed -e "s/$header:	//" | sed -e 's/, /\n/g')
        newtags=$(echo "$oldtags" | sed -re "s@$searchpat@$replpat@g")
        diffs=$(diff -u <(echo "$oldtags") <(echo "$newtags") | grep '^[+-]' | sed '1,2d' | sed -e 's/^/  /')

        if [ -z "$diffs" ]; then
            continue
        fi

        replwith="$header:	$(echo "$newtags" | tr '\n' ',' | sed -e 's/,/, /g' | sed -e 's/, $//')"
        if [ $doReplace == 1 ]; then
            sed -e "s@$headerline@$replwith@" "$filename" > repl.tmp
            rm "$filename"
            mv repl.tmp "$filename"
            echo "$filename modified"
        else
            echo -e "$filename:\n$diffs\n  =$replwith\n"
        fi
        numAffected=$((numAffected+1))
    done
    if [ $doReplace == 1 ]; then
        echo "Changed $numAffected $(numerize $numAffected file)."
    else
        echo "Changes will affect $numAffected $(numerize $numAffected file)."
        echo "To make these changes, rerun the command with the '-f' option."
    fi

    ;;

"check-validity"|"validate"|"cv")
    [ "$action" == "validate" ] && >&2 echo "WARNING: 'validate' is now 'check-validity'. 'validate' will be removed in a future version."
    validate_dreamdir
    ;;

"word-count"|"wc")
    dreamfind "$@"
    if [ -x "scripts/bin/drwc" ]; then
        scripts/bin/drwc -p $args
    else
        python2 <<WC_END
import scripts.ddirparse as dp
print dp.getCount("$args".split(' '), asPrettyString=True)
WC_END
    fi
    ;;

"stats"|"s")
    stats_display ;;

"regenerate-graphs"|"rg")
    scripts/RegeneratePlots.sh ;;

"last-lucid"|"ll")
    # shellcheck disable=2046
    # :: word splitting on the grep is correct
    "$EDITOR" $(grep -l 'Lucid:	' $dreamGlob | tail -n 1) ;;

"become-lucid"|"bl")
    echo "Nice try." ;;

"version"|"--version"|"v")
    echo "dr version $MYVERSION" ;;

"help"|"--help"|"h"|"-h"|*)
    if [[ "$1" == "search" || "$1" == "s" || "$1" == "edit" || "$1" == "find" ]]; then
        usagemsg_edit
    elif [[ "$1" == "header-replace" || "$1" == "hr" ]]; then
        usagemsg_header_replace
    else
        usagemsg
    fi
    ;;
esac

# shellcheck disable=2119
# :: we don't want 'popd "$@"', shellcheck.
[[ $didpush == 1 ]] && popd
exit 0
