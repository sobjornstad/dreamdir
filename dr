#!/bin/bash
# shellcheck disable=SC2086,SC1117

# %%% dr - Dreamdir utility program
# Copyright (c) 2015-2018 Soren Bjornstad; see LICENSE for details.

##### NOTES ON SHELLCHECK DIRECTIVES #####
# (For some stupid reason there can't be other comments between the shebang and
# the disable directives.)
# 1117: As stated on the official wiki page, this warning has been disabled in
#   the next release "due to being too pedantic".
# 2086: Turn off checks for variable quoting.
#   It's really too bad this has to be turned off, because it catches places
#   where variables really should have been quoted but were not. Unfortunately,
#   it flags passing around command-line arguments and lists of files like
#   "grep 'pattern' $dreamGlob" as errors, and as such produces a heap of
#   irrelevant warnings in this script. We could switch to using arrays
#   sometime in the future.


##### CONSTANTS #####
# application version
MYVERSION="2.0.X-devel"

# matching pattern for dream files
dreamGlob='[0-9][0-9][0-9][0-9][0-9].dre'


##### DOCUMENTATION / HELP MESSAGES #####
# usagemsg()
# Print the usage/help message and exit.
usagemsg() {
    cat <<USAGEMSG
dr - Dreamdir utility program
Copyright (c) 2015-2018 Soren Bjornstad; see LICENSE for details.

Usage: $(basename "$0") <action> [<action arguments>]
There are two types of actions, searches and utilities.

                             SEARCHES
Searches display some information about a subset of dreams. They take an
implied search expression after their other arguments; an empty search
expression selects all dreams. For information about search expressions, type
'$(basename "$0") help search'.

cat [-f]            :: print all content of matching dreams on stdout; if -f,
                       pass through 'fold -s' to limit line length to 80 chars
dump-headers        :: print headers of matching dreams
edit                :: pass matching dreams as args to \$EDITOR
find                :: show numbers of matching dreams
filename-display    :: print filenames of matching dreams
get-header <header> :: print values of header for matching dreams
header-values [-f] <header> :: show a list of all values used for <header>
                       in matching dreams (include frequency if -f)
list-headers [-f]   :: list headers used in at least one matching dream
                       (with frequency if -f specified)
word-count          :: show word count of the specified dreams, not
                       including headers
winnow              :: read filenames from stdin and AND them with
                       the results of another query
xwinnow             :: read filenames from stdin and XOR them with
                       the results of another query

                             UTILITIES
Utilities perform some other action.

act <search action> :: take <search action> on the list of filenames given on
                       stdin; useful at the end of a winnow pipeline
help                :: show this usage message
header-replace      :: regex search-and-replace on headers; type
                       '$(basename "$0") help header-replace' for info
new                 :: create a new dream with the next available ID
                       number and open it for editing
regenerate-tags     :: run scripts/vimtags.py to update the Vim tags list
check-validity      :: format sanity check: ensure all dreams have
                       IDs and dates and ID numbers are contiguous
version             :: print version number of this 'dr'

An action can be abbreviated by its initials (e.g., help: h, list-headers: lh).
USAGEMSG
    exit 0
}

# usagemsg_edit()
# Print the help on searching and exit.
usagemsg_edit() {
    cat <<USAGEMSG
                             DR - SEARCHING
$(basename "$0") <action> [<options>] <expr>

Select dreams matching search expression <expr> and take <action>
(available search actions are listed under 'dr help').

                             SEARCH EXPRESSIONS
A search expression is one or more of the following. If multiple search
expressions are given, their results will be concatenated.
  * a dream number (leading zeroes are allowed but not required)
  * a range of numbers: 12-18 or -18 (i.e., 1-18) or 12- (i.e., 12-last dream);
    leading zeroes are allowed but not required
  * a Bash globbing pattern for some dream numbers (leading zeroes are required)
  * a[ll]          :: select all dreams (same as a quoted '*')
  * b[ack] [<N>]   :: select the dream N positions from the end, inclusive
  * l[ast] [<N>]   :: like 'back', but select all dreams between N and the end
  * g[rep] <regex> :: select all dreams matching ERE <regex> anywhere in the
                      file (whether in headers, notes, or text)
  * t[agged] <header> <hregex> :: select dreams with <header> matching <hregex>
  * r[andom] [<N>] :: select N dreams randomly from your dreamdir, in numerical
                      order (add -s if desired)

N defaults to 1 if not provided.

A search expression may be entirely blank; in this case all dreams are
selected. Options are still parsed (see below).

Globbing patterns used in search expressions should be quoted (e.g., to edit
all dreams, use "dr edit '*'" , not "dr edit *").  They will be expanded either
way, but 'dr' can parse a glob more quickly than a very long argument list, so
the search will finish faster if you quote the pattern.  Note also that
including '.dre' is optional -- that is, '0100[34]' expands to '01003.dre
01004.dre'.

                             HREGEXES
<hregex>es are Extended Regular Expressions (EREs) that match only within
comma-separated items.  The ^ and $ anchors can be used to match the start and
end of a single item.  For example, with header "Tags: foo, bar baz, foobar":
  REGEX     :: MATCHES
  foo       :: 'foo' & 'foobar'
  bar       :: 'bar' & 'foobar'
  baz       :: 'bar baz'
  az        :: 'bar baz'
  .*baz     :: 'bar baz'
  ^ba.*az   :: 'bar baz'
  ^foobar$  :: 'foobar'
  ^baz$     :: -
  o, ba     :: -
  foo.*baz  :: -
Padding your expression with ^ and $ is often useful; otherwise 'cat' matches
'catalog' and 'duplicate'. If you want to avoid 'catalog' but still get 'cat
food', you can pad with '\\b' (word boundary).

With 'dr find tagged', a dream matches if any comma-separated item matches
the hregex.

With 'dr header-replace', only the specific comma-separated item that matches
is replaced.

                             OPTIONS
The following options may be used with any search expression. They are applied
to the results in this order if several are used:
  -v     :: invert match (show only dreams that do *not* match expression)
  -r     :: reverse the order of returned results
  -s     :: randomize (shuffle) the order of returned results
  -l <N> :: show only the first N results (if N is negative, remove N results
            from the end of the list)

                             EXAMPLES
dr edit 50                    :: edit dream number 50
dr filename-display 006[12]?  :: show the filenames of dreams #610-629
dr edit last 4 890            :: edit the last four dreams and #890
dr dump-headers 20 0[12]01*   :: show headers for dreams #20, #1010-1019,
                                 #2010-2019
dr get-header Tags '*'        :: get a listing of the tags of all your dreams
dr edit -s last 6             :: edit the last six dreams in a random order
dr cat -l 6 grep 'foo|bar'    :: print the first six dreams with a line
                                 containing the substring "foo" or "bar"
dr edit -r grep 'XX' back 20  :: edit the dream 20 from the end, then dreams
                                 containing "XX" in reverse numerical order
dr filename-display random 5  :: list the filenames of five random dreams
dr find tagged People Maud    :: edit dreams in which Maud appeared
dr edit tagged Tags '^cat$'   :: display dreams tagged with 'cat', but not
                                 'caterwaul' or 'dedicate'
dr fd 006[12]? |              :: display filenames for dreams #610-629 that
  dr winnow tagged Tags 'dog'    also have a tag containing 'dog'
dr fd t Tags '^cat$' |        :: show headers of dreams that are not tagged
  dr xwinnow grep '\\bcat\\b' |    exactly 'cat' but do use the word 'cat'
  dr act dump-headers            somewhere else
dr wc                         :: display a word count of all dreams
dr wc -sl 12 all              :: display a word count of 12 random dreams
USAGEMSG
    exit 0
}

usagemsg_header_replace() {
    cat <<USAGEMSG
                             DR - HEADER-REPLACE
$(basename "$0") header-replace [-f] <header> <find> <replace> <search-expr>

In dreams matching <search-expr>, replace instances of <find> in header
<header> with <replace>.  <header> and <replace> are EREs; <find> is
specifically an hregex (see 'help dr search' for more information).

<find> will not match across commas, but it may match and change several tags
separately.  For example, for the header 'Tags: bar, baz', we could find 'ba'
and replace with 'fo' and obtain 'Tags: for, foz', but a search for 'r, b' will
not match anything.

Each comma-separated value is considered a separate line, so we can search for
'^foobar$' to match only the entire tag 'foobar' and not, say, 'foobarbaz'.

                             PREVIEWING
Without the -f option, dr produces a preview of the changes your search-and-
replace will make.  Typical output looks like this:

    $ dr header-replace Tags "foo" "quux"
                    === Preview of changes to be applied ===
    01223.dre:
      -foo
      +quux
      =Tags:	quux, bar, baz

    Changes will affect 1 file.
    To make these changes, rerun the command with the '-f' option.

One section will be produced for each dream affected.  The first lines
underneath are a diff between the two sets of values.  The last line shows the
new header line that will be substituted in if you accept the changes.

                             RUNNING
After checking over the preview, rerun the command with the -f option to
actually make the changes.  Naturally, this can be quite dangerous with the
wrong regexes (e.g., a replacement of '.' with 'x' will completely trash all
your headers), so it's wise to make a backup first.  You'll also be required to
confirm interactively that you've double-checked the preview.

(NOTE: If the replace command gets interrupted in the middle, it is possible,
though very unlikely, that one of your dreams will have been deleted; you can
check this by seeing if 'dr check-validity' fails with a missing ID number.  If
this does occur you will find the content in the file 'repl.tmp' in your
dreamdir.)
USAGEMSG
}


##### UTILITY FUNCTIONS #####
# die()
# Print arguments to stderr and exit the shell with the last exit code.
#
# Arguments:
#     $1 - Message to complain with.
die() {
    ret=$?
    printf "%s\n" "$@" >&2
    exit $ret
}

# numerize()
# Display some string in singular or plural as appropriate.
#
# Arguments:
# $1 - the number to condition the singular/plural status on
# $2 - the singular form
# $3 - the plural form (optional; if not provided, defaults to singular + 's')
#
# Example:
# $ echo "I think there $(numerize $n "is" "are") $n $(numerize $n "foo") here."
# I think there is 1 foo here.
# I think there are 2 foos here.
numerize() {
    [ -n "$1" ] || die "Invalid arguments given to numerize()"
    [ -n "$2" ] || die "Invalid arguments given to numerize()"
    local num=$1
    local singular=$2
    if [ -z "$3" ]; then
        local plural="$singular"s
    else
        local plural=$3
    fi

    if [ "$num" -ne 1 ]; then
        echo "$plural"
    else
        echo "$singular"
    fi
}

# defileify()
# Given some dream filenames, convert them to comma-separated numbers, with no
# leading zeroes, and print the result.
#
# Arguments:
# (variable number) - the files to process
defileify() {
    echo "$@" | sed -e 's/\(^\| \)00*/\1/g' | sed -e 's/\.dre/,/g' | sed -e 's/,$//'
}

# colorify()
# Given a string, print the string with "syntax highlighting" for dreamdir
# syntax.
#
# Argument:
# $1 - the string to color

COL_HEADERS=$(tput setaf 2)
COL_LUCID=$(tput setaf 4)
COL_NOTES=$(tput setaf 6)
COL_VERBATIM=$(tput setaf 1)
COL_CLEAR=$(tput sgr0)

colorify() {
    # escape quotes and newlines so we can plop this into a Python string
	local txt
	txt=$(echo "$1" | sed -e 's/"/\\"/g' | perl -pe 's/\n/\\n/g')
	python2 <<-END
	# -*- coding: utf-8 -*-
	from scripts.ddirparse import strHighlight
	colors = {'headers': '$COL_HEADERS', 'lucid': '$COL_LUCID',
	          'notes': '$COL_NOTES', 'verbatim': '$COL_VERBATIM',
	          'clear': '$COL_CLEAR'}
	# we use rstrip to remove the trailing newline since that's what Bash would
	# do if we just printed it outright
	print strHighlight("$txt", colors).rstrip()
	END
}

# getrange()
# Given a range of dreams in the form Range ::= Number{*}@Number{*}, print
# a string of the filenames of dreams in that range (inclusive). If one of the
# numbers is missing, the first or last dream in the dreamdir is implied; '@'
# as a range is equivalent to all dreams.
#
# The @ will probably be input as something more sensible like '-'; we just use
# it as an internal separator because it doesn't conflict with command-line
# options.
#
# Called in several places in dreamfind().
#
# Argument:
# $1 - the range to find
#
# Example:
# $ echo "Filename list: $(getrange 4-8)"
# 00004.dre 00005.dre 00006.dre 00007.dre 00008.dre
getrange() {
    [ -n "$1" ] || "Invalid arguments given to getrange()"
    local startat; local endat
    startat=$(echo "$1" | cut -d '@' -f 1)
    endat=$(echo "$1" | cut -d '@' -f 2)
    if [ -z "$startat" ]; then
        dreamfind 1
        startat=$(defileify $args)
    fi
    if [ -z "$endat" ]; then
        dreamfind last
        endat=$(defileify $args)
    fi
    [ -n "$startat" ] || die "No results."
    [ -n "$endat" ] || die "No results."
    seq -f '%05g.dre' "$startat" "$endat"
}

# drwordcount()
# Call an appropriate program to return a word count.
#
# Arguments:
# $1 - "t" for machine-readable summary of all dreams combined
#          (normal lucid notes total)
#      "p" for pretty-printed complete display
# (variable) dream filenames to pass to the word count program
drwordcount() {
    local params
    if [ "$1" == "p" ]; then
        params="-p"
    elif [ "$1" == "t" ]; then
        params="-s"
    else
        die "Illegal arguments to drwordcount()!"
    fi
    shift

    # shellcheck disable=2068
    # :: word splitting on $@ is, in a rare happening, correct
    if [ -x "scripts/bin/drwc" ]; then
        scripts/bin/drwc $params $@
    else
        if [ "$params" == "-p" ]; then
            python2 <<WC_END
import scripts.ddirparse as dp
print dp.getCount("$@".split(' '), asPrettyString=True)
WC_END
        else
            python2 <<WC_END
import scripts.ddirparse as dp
print dp.getCount("$@".split(' '), asString=True)
WC_END
        fi
    fi
}


##### COMPLICATED ROUTINES #####
# dreamfind()
# Parse a search expression. The filenames of matching dreams are placed in the
# variable $args.
#
# This function may be used either to parse user input or to select dreams
# matching some pattern from within the script.
#
# Arguments:
# (variable number) A search expression, as input at the command line.
dreamfind() {
    # Before parsing optional arguments, we have to change the delimiter used
    # for ranges, because getopts isn't smart enough to see that "-20" is a
    # unidirectional range from 1-20, not two arguments "2" and "0".
    # http://unix.stackexchange.com/questions/258512/how-to-remove-a-positional-parameter-from
    for arg; do
        shift
        if [[ $arg =~ ^[0-9]*-[0-9]*$ ]]; then
            newarg="${arg//-/@}"
        else
            newarg="$arg"
        fi
        set -- "$@" "$newarg"
    done

    # Parse optional arguments to edit.
    df_doReverse=0    # global because a user that has to sort the results
    df_doShuf=0       # for further processing has to reapply these filters
    local limit=0
    local invert=0
    OPTIND=0  # if loop doesn't run at all, we need to make sure it's reset
    while getopts :rsl:v opt; do
        case $opt in
        r)
            df_doReverse=1 ;;
        s)
            df_doShuf=1 ;;
        l)
            limit="$OPTARG"
            [[ $limit =~ ^[0-9]+$ ]] || die "'$limit' is not a valid number of dreams to limit your search to."
            ;;
        v)
            invert=1 ;;
        *)
            die "Invalid option (-rslv are valid; see 'dr help search')."
        esac
    done
    shift $((OPTIND-1))

    # No arguments is equivalent to "all".
    if [ -z "$1" ]; then
        # http://stackoverflow.com/questions/13762370/
        # assigning-to-a-positional-parameter
        set -- "all"
    fi

    # Now compile a list of all the dreams we've specified.
    args=""
    local newargs=""
    local howMany=0
    while [ ! -z "$1" ]
    do
        if [[ $1 =~ ^[0-9][0-9]*$ ]]; then
            local num=$((10#$1))
            printf -v newargs '%05d.dre' "$num"
        elif [[ $1 =~ ^[0-9]*@[0-9]*$ ]]; then
            newargs=$(getrange "$1")
        else case "$1" in
        "last"|"back"|"l"|"b")
            local action=$1
            if [[ ! -z "$2" && $2 =~ ^[0-9]+$ ]]; then
                howMany="$2"
                shift
            else
                howMany=1
            fi
            newargs=$(find $dreamGlob | tail -n "$howMany")
            if [[ "$action" == "back" || "$action" == "b" ]]; then
                newargs=$(echo "$newargs" | head -n 1)
            fi
            ;;
        
        "grep"|"g")
            [ -n "$2" ] || die "'grep' needs a pattern. (See 'dr help search' for help.)"
            newargs=$(grep -El "$2" $dreamGlob)
            shift
            ;;

        "random"|"r")
            if [[ ! -z "$2" && $2 =~ ^[0-9]+$ ]]; then
                howMany=$2
                shift
            else
                howMany=1
            fi
            newargs=$(find $dreamGlob | shuf | head -n "$howMany" | sort)
            ;;

        "all"|"a")
            newargs=$dreamGlob
            ;;

        "tagged"|"t")
            local usage="Usage: dr $action tagged <header regex> <value regex>"
            [ -n "$2" ] || die "$usage"
            [ -n "$3" ] || die "$usage"
            # The idea here is to replace the delimiters with '@@@@@' (which we
            # can fairly safely assume will not show up in a tag), then change
            # the user's regex to match '@@@@@' as BOL/EOL and not cross it
            # with '.'.
            local header="$2"
            local pattern
            pattern=$(echo "$3" | sed -e 's/[$^]/@@@@@/' | sed -e 's/\$/[$@]/' | sed -e 's/\./[^@]/')
            newargs=$(grep -m 1 "$header:	" $dreamGlob | sed -e "s/$header:	/@@@@@/" | sed -e 's/, /@@@@@/g' | sed -e 's/$/@@@@@/' | grep -E "[0-9]{5}\.dre:.*$pattern" | sed -e 's/\([0-9]\{5\}\.dre\):.*/\1/')
            shift; shift
            ;;

        *) # filename glob
            if echo "$1" | grep -q ".dre"; then
                newargs="$1"
            else
                newargs="$1.dre"
            fi
        esac
        fi  # regex matches

        # Add args parsed to the complete list and proceed. Note that if a type
        # of expression has arguments, it's responsible for shifting those away
        # before it finishes.
        args="$args $newargs"
        shift
    done

    # apply option flags
    # shellcheck disable=2086
    # :: We *don't* want $args to be quoted -- we're doing this to expand globs.
    args=$(echo $args | cat -)
    if [ $invert -eq 1 ]; then
        args=$(comm -3 <(find $dreamGlob | tr ' ' '\n' | sort) <(echo "$args" | tr ' ' '\n' | sort))
    fi
    [ $df_doReverse -eq 1 ] && args=$(echo "$args" | tr ' ' '\n' | tac)
    [ $df_doShuf -eq 1 ]    && args=$(echo "$args" | tr ' ' '\n' | shuf)
    [ $limit -ne 0 ]        && args=$(echo "$args" | tr ' ' '\n' | head -n $limit)

    # sanity check
    [ -z "$args" ] && die "No results."
    for i in $args
    do
        [ -f "$i" ] || die "Matched nonexistent file '$i'; please check your search terms and try again.\n(Type 'dr help search' for help.)"
    done
}

# validate_dreamdir()
# Check to see if our dreamdir's format is okay.
validate_dreamdir() {
    # set up temp file for checking id and date headers
    local tempfile="/tmp/dreamgrep" # contains list of dream files
    [ ! -e $tempfile ] || die "Please check & remove existing temp file $tempfile and try again."
    find . -maxdepth 1 -name "$dreamGlob" | sort | cut -c 3- > "$tempfile"

    # check for id problems
    local checkFailedFor
    if checkFailedFor=$(grep -l 'Id:	[0-9]\{5\}' $dreamGlob | sort | diff - "$tempfile"); then
        echo "ID value check...OK"
    else
        echo "ID value check...FAILED"
        echo "The files listed in the following diff have missing or incomplete"
        echo "Id headers:"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi

    # check for date problems (similar -- consider a function)
    if checkFailedFor=$(grep -l 'Date:	[12][901][0-9]\{2\}-[01][0-9]-[0123][0-9]' $dreamGlob | sort | diff - "$tempfile"); then
        echo "Date check...OK"
    else
        echo "Date check...FAILED"
        echo "The files listed in the following diff have missing or invalid"
        echo "Date headers, or represent implausible or impossible dates."
        echo "(Note: dates must be in YYYY-MM-DD format.)"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi
    rm "$tempfile"

    # check for ID continuity
    # works with Python 2 & 3 -- check dual compatibility after changes
    python <<PYTH_ID_CHECK
import os, sys
listing = sorted(os.listdir('.'))
listing = filter(lambda i: i.endswith('.dre'), listing)
nums = []
for i in listing:
    try:
        nums.append(int(i))
    except ValueError:
        # not a dream file, but auxiliary of some kind
        continue

lastnum = 0
for i in nums:
    if i != lastnum+1:
        print("ID continuity check...FAIL")
        print("Failure was on ID %i, not continuous with previous ID %i." % (
              i, lastnum))
        sys.exit(1)
    else:
        lastnum = i
print("ID continuity check...OK")
sys.exit(0)
PYTH_ID_CHECK
    if [ $? != 0 ]; then
        exit 1
    fi

    echo "All tests succeeded."
}

##### MAIN SCRIPT #####
# If DREAMDIR environment variable is set and we're not already in $DREAMDIR,
# change directory into it until the end of the script.
if [[ ! -z "$DREAMDIR" && "$PWD" != "$DREAMDIR" && ! -f ".dreamdir" ]]; then
    if ! cd "$DREAMDIR"; then
        echo "ERROR: The current directory is not a dreamdir and the DREAMDIR"
        echo "environment variable is set to an invalid directory"
        echo "($DREAMDIR). Exiting."
        exit 1
    fi
fi

# Confirm that we've ended up in a dreamdir.
[ -f .dreamdir ] || die "Please run this script from a dreamdir, or set the environment variable \$DREAMDIR to the path to your dreamdir."

# Figure out what action we're going to do and jump to appropriate code.
[ -z "$1" ] && usagemsg
action="$1"
shift # arguments to actions start at $1

case "$action" in
"new"|"n")
    today=$(date '+%Y-%m-%d')
    lastNum=$(find $dreamGlob | sort | tail -n 1 | cut -c 1-5)
    [ -f $lastNum.dre ] || die "Unable to correctly find last dream number. Please ensure no non-dream files in the dreamdir end with '.dre'. (Pulled '$lastNum'.)"
    newNum=$((10#$lastNum + 1))
    printf -v newNum '%05d' "$newNum"

    # http://unix.stackexchange.com/questions/88490/how-do-you-use-output-redirection-in-combination-with-here-documents-and-cat
    ed <<NEWDREAM >/dev/null 2>&1
i
Id:	$newNum
Date:	$today
Time:	
Title:	
People:	
Places:	
Tags:	


.
w $newNum.dre
w /tmp/$newNum.dre
q
NEWDREAM

    if [ "$EDITOR" == "vim" ]; then
        # use vim's option to place the cursor on the last line
        vim "$newNum.dre" +
    else
        "$EDITOR" "$newNum.dre"
    fi
    if diff "/tmp/$newNum.dre" "$newNum.dre" > /dev/null 2>&1; then
        echo "Deleting unmodified dream file."
        rm "$newNum.dre"
    else
        chmod 600 "$newNum.dre" # dreams default to 600 for basic privacy
    fi
    rm "/tmp/$newNum.dre"
    ;;

"edit"|"e")
    dreamfind "$@"
    "$EDITOR" $args
    ;;

"find"|"f")
    dreamfind "$@"
    # remove leading zeroes and '.dre' for display, add separator commas
    results="$(defileify $args)"
    numMatches="$(echo $results | wc -w)"
    echo -e "$numMatches $(numerize $numMatches "match" "matches"): [$results]"
    ;;

"filename-display"|"fd")
    dreamfind "$@"
    echo "$args"
    ;;

"winnow"|"w"|"xwinnow"|"x")
    if [[ "$action" == "winnow" || "$action" == "w" ]]
    then commparams="-12"
    else commparams="-3"
    fi

    read -r toFilter
    [ -z "$toFilter" ] && die "'dr winnow' requires a list of filenames on stdin, usually piped from\n'winnow' or 'filename-display'. (Type 'dr help' for help.)"
    for i in $toFilter; do
        [ -f "$i" ] || die "'$i' is not a dream filename.\nDid you forget to start your pipeline with 'filename-display'?\n(Type 'dr help' for help.)"
    done

    dreamfind "$@"
    results=$(comm $commparams <(echo "$toFilter" | tr ' ' '\n' | sort) <(echo "$args" | tr ' ' '\n' | sort))
    # since comm needs sorted content, we have to reapply the order changes
    [ $df_doReverse == 1 ] && results=$(echo "$results" | tac)
    [ $df_doShuf == 1 ]    && results=$(echo "$results" | shuf)
    echo "$results"
    ;;

"get-header"|"gh")
    #TODO: Possibility of formatting options (filename or number, remove
    #leading 0's, include header name)
    usageMsg="Usage: $(basename "$0") get-header <header> <search-expr>"
    [ -n "$1" ] || die "$usageMsg"
    getHeader=$1
    shift
    dreamfind "$@"
    grep "$getHeader:	" $args | sed -e "s/$getHeader:	\(.*\)/\1/" | sed -e 's/^00*\([0-9]\+\).dre:/\1: /'
    ;;

"dump-headers"|"dh")
    dreamfind "$@"
    for i in $args; do
        [ ! -f "$i" ] && echo "File $i not found."
        text=$(awk '{ if(!$0) exit; print $0; }' < "$i")
        if [ -t 1 ]; then
            # running in an interactive terminal
            colorify "$text"
        else
            echo "$text"
        fi
        echo ""
    done
    ;;

"cat"|"c")
    if [ "$1" == "-f" ]; then
        printCommand="fold -s"
        shift
    else
        printCommand="cat"
    fi

    dreamfind "$@"
    for i in $args; do
        text=$($printCommand "$i")
        if [ -t 1 ]; then
            # running in an interactive terminal
            colorify "$text"
        else
            echo "$text"
        fi
        echo -en "\n\n"
    done
    ;;

"list-headers"|"lh")
    if [ "$1" == "-f" ]; then
        showFreq=1
        shift
    else
        showFreq=0
    fi
    dreamfind "$@"
    results=$(grep -h '^.*:	' $args | sed -e 's/^\(.*\):	.*$/\1/' | sort)
    if [ $showFreq == 1 ]; then
        echo "$results" | uniq -c | sort -b -k 1rn -k 2
    else
        echo "$results" | uniq
    fi
    ;;

"header-values"|"hv")
    if [ "$1" == "-f" ]; then
        showfreq=1
        shift
    else
        showfreq=0
    fi
    [ -n "$1" ] || die "Please specify a header type, like '$(basename "$0") header-values Tags'."
    header="$1"
    shift
    dreamfind "$@"

    results=$(grep "$header:	" $args | sed -e 's/.*:	//' | sed -e 's/, /\n/g' | sort)
    if [ $showfreq == 1 ]; then
        echo "$results" | uniq -c | sort -b -k 1rn -k 2
    else
        echo "$results" | uniq
    fi
    ;;

"header-replace"|"hr")
    usageMsg="Usage: $(basename "$0") header-replace [-f] <header> <search> <replace> <search-expr>\nType 'dr help header-replace' for details."
    [ -n "$1" ] || die "$usageMsg"
    [ -n "$2" ] || die "$usageMsg"
    [ -n "$3" ] || die "$usageMsg"
    [[ "$2" =~ @ || "$3" =~ @ ]] && \
        die "Sorry, at-signs (@) are not valid in search/replace regexes."

    if [ "$1" == "-f" ]; then
        doChange=1
        shift
    else
        doChange=0
    fi

    header="$1"
    searchpat="$2"
    replpat="$3"
    shift; shift; shift

    # Since the replace loop is rather expensive, compile a list of dreams that
    # both match our search-expr and include the <search> hregex, and look only
    # at those.
    dreamfind "$@"
    affectOnlyDreams="$args"
    dreamfind tagged "$header" "$searchpat"
    args=$(comm -12 <(echo "$affectOnlyDreams" | tr ' ' '\n') \
                    <(echo "$args" | tr ' ' '\n'))

    # If we're actually making changes, confirm that we really want to.
    if [ $doChange == 1 ]; then
        numToChange=$(echo "$args" | wc -w)
        echo "You are about to apply a search-and-replace that will affect" \
        "$numToChange $(numerize "$numToChange" dream)."
        if [ "$numToChange" -ge 50 ]; then
            echo -e "\e[1;31mThat looks like quite a few dreams.\e[0m"
        fi
        echo "If this doesn't sound right, please check the results without -f first!"
        read -rp "Do you wish to continue (y/n)? " doCont
        if [ "$doCont" != "y" ]; then
            exit 0
        fi
        doReplace=1
        shift
    else
        echo "                    === Preview of changes to be applied ==="
        doReplace=0
    fi

    numAffected=0
    for filename in $args
    do
        headerline=$(grep -m 1 "$header:	" "$filename")
        oldtags=$(echo "$headerline" | sed -e "s/$header:	//" | sed -e 's/, /\n/g')
        newtags=$(echo "$oldtags" | sed -re "s@$searchpat@$replpat@g")
        diffs=$(diff -u <(echo "$oldtags") <(echo "$newtags") | grep '^[+-]' | sed '1,2d' | sed -e 's/^/  /')

        if [ -z "$diffs" ]; then
            continue
        fi

        replwith="$header:	$(echo "$newtags" | tr '\n' ',' | sed -e 's/,/, /g' | sed -e 's/, $//')"
        if [ $doReplace == 1 ]; then
            sed -e "s@$headerline@$replwith@" "$filename" > repl.tmp
            rm "$filename"
            mv repl.tmp "$filename"
            echo "$filename modified"
        else
            echo -e "$filename:\n$diffs\n  =$replwith\n"
        fi
        numAffected=$((numAffected+1))
    done
    if [ $doReplace == 1 ]; then
        echo "Changed $numAffected $(numerize $numAffected file)."
    else
        echo "Changes will affect $numAffected $(numerize $numAffected file)."
        echo "To make these changes, rerun the command with the '-f' option."
    fi

    ;;

"check-validity"|"validate"|"cv")
    [ "$action" == "validate" ] && >&2 echo "WARNING: 'validate' is now 'check-validity'. 'validate' will be removed in a future version."
    validate_dreamdir
    ;;

"word-count"|"wc")
    dreamfind "$@"
    drwordcount "p" "$args"
    ;;

"regenerate-tags"|"rt")
    scripts/vimtags.py ;;

"act"|"a")
    [ -n "$1" ] || die "Usage: [chain of piped dr commands] | dr act <search action>"
    input=$(cat <&0)
    "$0" "$@" $input
    ;;

"become-lucid"|"bl")
    echo "Nice try." ;;

"version"|"--version"|"v")
    echo "dr version $MYVERSION" ;;

"help"|"--help"|"h"|"-h"|*)
    if [[ "$1" == "search" || "$1" == "s" || "$1" == "edit" || "$1" == "find" ]]; then
        usagemsg_edit
    elif [[ "$1" == "header-replace" || "$1" == "hr" ]]; then
        usagemsg_header_replace
    else
        usagemsg
    fi
    ;;
esac

exit 0
