#!/bin/bash
# %%% dr - Dreamdir utility program
# Copyright (c) 2015-2016 Soren Bjornstad; see LICENSE for details.

# application version
MYVERSION="0.2"

# usagemsg()
# Print the usage/help message and exit.
usagemsg() {
    cat <<USAGEMSG
dr - Dreamdir utility program
Copyright (c) 2015-2016 Soren Bjornstad; see LICENSE for details.

Usage: `basename $0` <action> [<action arguments>]
An action can be abbreviated by its initials (e.g., help: h, open-tagged: ot)

Available actions:
help                           :: show this usage message
new                            :: create a new dream with the next available ID
                                  number and open it in \$EDITOR
edit                           :: edit one or more dreams (more information:
                                  'dr help edit')
find-tagged <header> [<regex>] :: list dreams matching Python regex
open-tagged <header> [<regex>] :: pass find-tagged results as args to \$EDITOR
list-headers [-f]              :: list headers used in at least one dream (with
                                  frequency if -f specified)
header-values [-f] <header>    :: show a list of all values used for <header> in
                                  any dream (include frequency if -f)
last-lucid                     :: edit the dream with the highest number that
                                  has a Lucid header
cat [<file>]                   :: concatenate all dream files to form a single
                                  output stream, written to stdout or <file>
regenerate-graphs              :: run scripts/RegeneratePlots.sh to make graphs
stats                          :: display dream statistics
validate                       :: format sanity check: ensure all dreams have IDs
                                  and dates and ID numbers are contiguous
USAGEMSG
    exit 0
}

usagemsg_edit() {
    cat <<USAGEMSG
dr - Dreamdir utility program
Copyright (c) 2015-2016 Soren Bjornstad; see LICENSE for details.

Usage: `basename $0` edit [<options>] <expression> [<expression args>]
Open the dreams specified by the edit expression <expression> in \$EDITOR.

An edit expression is one or more of the following:
* a dream number
* a filename globbing pattern
* b[ack] [<N>]   :: select the dream N positions from the end, inclusive
* l[ast] [<N>]   :: like 'back', but select all dreams between N and the end
* g[rep] <regex> :: select all dreams containing the pattern anywhere in the
                    file (whether in headers, notes, or text)
* r[andom] [<N>] :: select N dreams randomly from your dreamdir, in numerical
                    order (add -s if desired)

N defaults to 1 if not provided.

The following options may be used with any edit expression:
-r: Reverse the order of returned results.
-s: Randomize (shuffle) the order of returned results.
-l: Just print the filenames that would be passed to the editor to stdout,
    rather than actually starting it.

Examples:
dr edit 50                  :: edit dream number 50
dr edit 006[12]?            :: edit dreams 610-629
dr edit last 4 890          :: edit the last four dreams and #890
dr edit -l 20 0[12]01*      :: list the filenames of #20, #1010-1019, #2010-2019
dr edit -s l 6              :: edit the last six dreams in a random order
dr edit grep 'Maud\|Ellie'  :: edit dreams with a line containing "Maud" or
                               "Ellie"
dr edit -r g 'XX' b 20      :: edit the dream 20 from the end, then dreams
                               containing "XX" in reverse numerical order
dr edit -l random 5         :: display the filenames of five random dreams
USAGEMSG
    exit 0
}

# ensure()
# Make sure a condition necessary for script execution is true.
#
# Arguments:
#     $1 - an argument to `test`
#     $2 - a message to display if the test fails
#	  $3 - (optional, default 1) exit status to return if the test fails
# State change & return:
#     If the test evaluates non-zero, the script prints $2 and exits with
#     status $3 (or 1). Else, control returns to the caller.
ensure() {
    eval "test $1"
    if [ $? -ne 0 ]
    then
        if [ -z "$3" ]; then
            exitval=1
        else
            exitval=$3
        fi
        echo -e "$2"
        exit $exitval
    else
        return 0
    fi
}

# die()
# Unconditionally exit the shell with status 1 after printing the given error.
#
# Arguments:
#     $1 - Message to complain with.
die() {
    echo "$1"
    exit 1
}

# don't display the directory stack on push/pop
pushd () {
    command pushd "$@" > /dev/null
}
popd () {
    command popd "$@" > /dev/null
}


##### Begin main script #####

# If DREAMDIR environment variable is set and we're not already in $DREAMDIR,
# change directory into it until the end of the script.
didpush=0
oldpwd="$PWD" # if we need to know where the user is running the script from
if [[ ! -z "$DREAMDIR" && "$PWD" != "$DREAMDIR" && \
      ! -d scripts && ! -d graphs && ! -f dr ]]; then
    didpush=1
    pushd "$DREAMDIR"
    if [[ $? != 0 ]]; then
        echo "ERROR: The current directory is not a dreamdir and the DREAMDIR"
        echo "environment variable is set to an invalid directory"
        echo "($DREAMDIR). Exiting."
        exit 1
    fi
fi

# Confirm that we've ended up in a dreamdir.
error="Please run this script from a dreamdir, or set the environment\n"\
"variable \$DREAMDIR to the path to your dreamdir."
ensure '-d scripts' "$error"
ensure '-d graphs'  "$error"
ensure '-f dr'      "$error"

[ -z "$1" ] && usagemsg
action="$1"
shift # arguments to actions start at $1

case "$action" in
"new"|"n")
    oldUmask=$(umask)
    umask 0177 # dreams default to 600 for basic privacy
    today=$(date '+%Y-%m-%d')
    lastNum=$(ls *.dre | sort | tail -n 1 | cut -c 1-5)
    ensure "-f $lastNum.dre" "Unable to correctly find last dream number. Please ensure no non-dream files in the dreamdir end with '.dre'. (Pulled '$lastNum'.)"
    let newNum=10#$lastNum+1
    printf -v newNum '%05d' "$newNum"
    echo -e "Id:\t$newNum"   > $newNum.dre
    echo -e "Date:\t$today" >> $newNum.dre
    echo -e "Time:\t"       >> $newNum.dre
    echo -e "Tags:\t"       >> $newNum.dre
    echo -e "\n"            >> $newNum.dre
    cp $newNum.dre /tmp
    if [ "$EDITOR" == "vim" ]; then
        # use vim's option to place the cursor on the last line
        vim $newNum.dre +
    else
        "$EDITOR" $newNum.dre
    fi
    diff /tmp/$newNum.dre $newNum.dre > /dev/null 2>&1
    if [ $? == 0 ]; then
        echo "Deleting unmodified dream file."
        rm "$newNum.dre"
    fi
    rm "/tmp/$newNum.dre"
    umask $oldUmask
    ;;

"list-headers"|"lh")
    if [[ "$1" == "-f" ]]; then
        grep -h '^.*:	' *.dre | sed -e 's/^\(.*\):	.*$/\1/' | sort | \
                uniq -c | sort -b -k 1rn -k 2
    else
        grep -h '^.*:	' *.dre | sed -e 's/^\(.*\):	.*$/\1/' | sort | uniq
    fi
    ;;

"header-values"|"hv")
    if [[ "$1" == "-f" || "$2" == "-f" ]]; then
        showfreq=1
        [[ "$1" == "-f" ]] && shift # force header type to $1 in either order
    else
        showfreq=0
    fi
    ensure "! -z \"$1\"" "Please specify a header type, like '`basename $0` header-values Tags'."

    results=$(grep "$1:	" *.dre | cut -d ':' -f 3 | cut -c 2- | \
    #results=$(grep "$1:	" *.dre | awk '{split($0, a, ":"); print a[4],a[3],a[2],a[1]}' | cut -c 2- | \
            sed -e 's/, /\n/g' | sort)
    if [ $showfreq == 1 ]; then
        echo "$results" | uniq -c | sort -b -k 1rn -k 2
    else
        echo "$results" | uniq
    fi
    ;;

"grep"|"g")
    results=$(grep -l "$*" [0-9][0-9][0-9][0-9][0-9].dre)
    echo -n "["
    echo -n "$(echo $results | wc -w) matches: "
    for i in $results
    do
        echo -n "$((10#`basename $i .dre`)), "
    done
    echo -e "\b\b]"
    ;;

"cat"|"c")
    if [ ! -z "$1" ]; then
        # save old stdout, then redirect it to specified file, changing into
        # the directory 'dr' was run from to do the redirect if necessary
        [ $didpush == 1 ] && pushd "$oldpwd"
        ensure "! -f $1" "$1 exists, not overwriting."
        exec 4<&1
        exec 1>"$1" || die "Could not write to specified file, see above."
        [ $didpush == 1 ] && popd
    fi
    for i in *.dre; do
        cat "$i"
        echo -en "\n\n"
    done
    [ ! -z "$1" ] && exec 1<&4 # restore old stdout
    ;;

"validate"|"v")
    # set up temp file for checking id and date headers
    tempfile="/tmp/dreamgrep" # contains list of dream files
    ensure "! -e $tempfile" "Please check & remove existing temp file $tempfile and try again."
    ls *.dre | sort > "$tempfile"

    # check for id problems
    checkFailedFor=$(grep -l 'Id:	[0-9]\{5\}' *.dre | sort | diff - "$tempfile")
    if [ $? == 0 ]; then
        echo "ID value check...OK"
    else
        echo "ID value check...FAIL"
        echo "The files listed in the following diff have missing or incomplete"
        echo "Id headers:"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi

    # check for date problems (similar -- consider a function)
    checkFailedFor=$(grep -l 'Date:	[12][901][0-9]\{2\}-[01][0-9]-[0123][0-9]' *.dre | sort | diff - "$tempfile")
    if [ $? == 0 ]; then
        echo "Date check...OK"
    else
        echo "Date check...FAIL"
        echo "The files listed in the following diff have missing or invalid"
        echo "Date headers, or represent implausible or impossible dates."
        echo "(Note: dates must be in YYYY-MM-DD format.)"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi
    rm "$tempfile"

    # check for ID continuity
    # works with Python 2 & 3 -- check dual compatibility after changes
    python <<PYTH_ID_CHECK
import os, sys
listing = sorted(os.listdir('.'))
listing = filter(lambda i: i.endswith('.dre'), listing)
nums = []
for i in listing:
    try:
        nums.append(int(i))
    except ValueError:
        # not a dream file, but auxiliary of some kind
        continue

lastnum = 0
for i in nums:
    if i != lastnum+1:
        print("ID continuity check...FAIL")
        print("Failure was on ID %i, not continuous with previous ID %i." % (
              i, lastnum))
        sys.exit(1)
    else:
        lastnum = i
print("ID continuity check...OK")
sys.exit(0)
PYTH_ID_CHECK
    if [ $? != 0 ]; then
        exit 1
    fi

    echo "All tests succeeded."
    ;;

"find-tagged"|"ft")
    ensure "! -z \"$1\"" "Usage: `basename $0` find-tagged <header> [<value>]."
    header="$1"
    shift
    python2 <<PYTH_FINDTAGGED
import scripts.ddirparse as dp
dreams = dp.getDreamsTagged("$header", "$@")
print "%i matches: %r" % (len(dreams), dreams)
PYTH_FINDTAGGED
    ;;

"open-tagged"|"ot")
    # Do a find using the same method as find-tagged but then open those files
    # for editing rather than just showing a list of the numbers.
    tempfile="/tmp/dreamsearch"
    ensure "! -e $tempfile" "Please check & remove existing temp file $tempfile and try again."
    header="$1"
    shift # value to search for remains in args

    python2 <<PYTH_SHOWTAGGED
import scripts.ddirparse as dp
dreams = dp.getDreamsTagged("$header", "$@")
dreamStr = '.dre '.join([("%05i" % i) for i in dreams]) + '.dre'
with open("$tempfile", "w") as f:
    f.write(dreamStr)
PYTH_SHOWTAGGED
    args=$(cat "$tempfile")

    if [ "$args" == ".dre" ]; then
        echo "Sorry, no results for that query."
        rm "$tempfile"
        exit 1
    else
        "$EDITOR" $args
        rm "$tempfile"
    fi
    ;;

"stats"|"s")
    echo "Crunching the latest numbers for you, just a moment..."
    colOn='[1;34m'
    colOff='[0m'

    today=$(date '+%Y-%m-%d')
    filenamesToday=$(grep -l "Date:	$today" *.dre)
    if [ ! -z "$filenamesToday" ]; then
        dreamsToday=$(echo $filenamesToday | sed -e 's/\.dre'//g | sed -e 's/ 0*/ /g' | sed -e 's/^0*//') # NOT very clean.
        numDreamsToday=$(echo $dreamsToday | wc -w)
        dreamsTodayDisp=$(echo $dreamsToday | sed -e 's/ /, /g')
        lucidsToday=$(grep 'Lucid:	' $filenamesToday | wc -l)
        wordCountToday=$(wc -w $filenamesToday | tail -n 1 | sed -e 's/^ *//' | cut -d ' ' -f 1)
        if [ -f $wordCountToday ]; then
            # there was only one dream and no "total" line, so we pulled out the wrong thing
            wordCountToday=$(wc -w $filenamesToday | cut -d ' ' -f 1)
        fi
    fi

    numDreams=$(ls *.dre | wc -l)
    wordCount=$(wc *.dre -w | tail -n 1 | cut -d ' ' -f 2)
    avgWordCount=$((wordCount / numDreams))
    dateStats=$(python2 <<'PYTH_DATEFREQ'
# OUTPUT FORMAT:
# <number of dates recorded> <earliest date> <latest date> <date with most dreams> <how many that was>
import scripts.ddirparse as dp
dateattrs = dp.getAttribForAllDreams('Date')
dates = [i.split('\t')[1] for i in dateattrs.values()]
freqs = {}
for date in dates:
    freqs[date] = freqs.get(date, 0) + 1
keyList = freqs.keys()
print len(keyList),
print min(keyList),
print max(keyList),
# create list of keys sorted by the order of their values, min to max
byFreq = sorted(keyList, cmp=lambda a,b: cmp(freqs[a],freqs[b]))
print byFreq[-1],       # most number of dreams
print freqs[byFreq[-1]] # how many?
PYTH_DATEFREQ
)
    mostWordsDay=$(python2 <<'PYTH_MOSTWORDS'
# Getting acceptable performance here requires unfolding some possible
# functions and abstractions into this (nevertheless simple enough) loop.
# TODO: This should be a function in scripts.ddirparse, I can think of tons of
# other good things to do with this, like graphing and printing a table.
import scripts.ddirparse as dp
wcs = {}
for f in dp.allDreamfiles():
    date = None
    counting = False
    for line in f:
        textline = line.strip()
        if counting:
            wcs[date] += len(textline.split())
        else:
            if textline.startswith('Date:\t'):
                date = textline.split(':\t')[1].strip()
            elif not textline:
                # end of headers, start counter
                counting = True
                if date not in wcs:
                    wcs[date] = 0
# create list of keys sorted by the order of their values, max to min
wcOrder = sorted(wcs.keys(), cmp=lambda a,b: cmp(wcs[b],wcs[a]))
print wcOrder[0], wcs[wcOrder[0]], # # of dreams, date of it
print len(dp.getDreamsTagged('Date', wcOrder[0])) # how many dreams
PYTH_MOSTWORDS
)
    datesRecorded=$(echo "$dateStats" | cut -d ' ' -f 1)
    avgDreamsPerDay=$(echo "scale=2; $numDreams / $datesRecorded" | bc -q)
    earliestDate=$(echo "$dateStats" | cut -d ' ' -f 2)
    latestDate=$(echo "$dateStats" | cut -d ' ' -f 3)
    mostDreamsDate=$(echo "$dateStats" | cut -d ' ' -f 4)
    numMostDreams=$(echo "$dateStats" | cut -d ' ' -f 5)

    mostWordsOnDay=$(echo "$mostWordsDay" | cut -d ' ' -f 1)
    mostWords=$(echo "$mostWordsDay" | cut -d ' ' -f 2)
    dreamsInMostWordsDay=$(echo "$mostWordsDay" | cut -d ' ' -f 3)
    mostWordsDream=$(wc -w *.dre | sort -n | sed -e '$ d' | tail -n 1)
    mostWordsDreamNum=$(echo "$mostWordsDream" | sed -e 's/^ *[0-9]\+ 0*\([0-9]\+\).dre$/\1/')
    mostWordsDreamCount=$(echo "$mostWordsDream" | sed -e 's/^ *\([0-9]\+\).*/\1/')

    lucidFilenames=$(grep -l 'Lucid:	' *.dre)
    numLucids=$(echo $lucidFilenames | wc -w) # -w: $() collapses \n to space
    percentLucid=$(echo "scale=2; 100 * $numLucids / $numDreams" | bc -q)
    totalLucidWordCount=$(wc -w $lucidFilenames | tail -n 1 | cut -d ' ' -f 2)
    avgLucidWordCount=$((totalLucidWordCount / numLucids))
    percentLucidWordCount=$(echo "scale=2; 100 * $totalLucidWordCount / $wordCount" | bc -q)
    daysRecordedLds=$(python2 <<'PYTH_DAYS_LDS'
# Output format: <days with recorded LDs>
import scripts.ddirparse as dp
lucids = dp.getDreamsTagged('Lucid', '')
allDates = dp.getAttribForAllDreams('Date')
allDates = {k: v.split('\t')[1] for k,v in allDates.iteritems()}
# Use a dictionary to make future expansion to frequency, etc., easier
lucidDays = {}
for i in lucids:
    lucidDays[allDates[i]] = lucidDays.get(allDates[i], 0) + 1
print len(lucidDays)
PYTH_DAYS_LDS
)
    percentDaysRecordedLds=$(echo "scale=2; 100 * $daysRecordedLds / $datesRecorded" | bc -q)

# Consider, inserting commas into a number:
# echo "$number" | rev | sed 's/\([0-9][0-9][0-9]\)\([0-9]\)/\1,\2/g' | rev

echo -e "${colOn}Today$colOff"
echo -e "Today: $today"
if [ -z "$filenamesToday" ]; then
    echo -e "No dreams recorded today.\n"
else
    echo -e "Dreams recorded today: $numDreamsToday ($dreamsTodayDisp)"
    echo -e "Lucid dreams recorded today: $lucidsToday"
    echo -e "Total word count today: $wordCountToday\n"
fi
cat <<STATS_DISP
${colOn}Recall and recording$colOff
Total dreams: $numDreams
Days with recorded dreams: $datesRecorded
Average dreams per recorded day: $avgDreamsPerDay
Date range: $earliestDate – $latestDate
Day with most dreams: $mostDreamsDate ($numMostDreams)
Total word count: $wordCount
Average words per dream: $avgWordCount
Day with highest word count: $mostWordsOnDay ($mostWords words over $dreamsInMostWordsDay dreams)
Single dream with highest word count: #$mostWordsDreamNum ($mostWordsDreamCount words)

${colOn}Lucidity$colOff
Total lucid dreams: $numLucids
Percentage lucid: $percentLucid%
Days with recorded LDs: $daysRecordedLds
Percentage recorded days with at least one LD: $percentDaysRecordedLds%
Total lucid word count: $totalLucidWordCount
Average words per lucid dream: $avgLucidWordCount
Percentage of words in lucid dreams: $percentLucidWordCount%

${colOn}Table summary${colOff}
		Total	Avg	Max/Day	Today
# of dreams	$numDreams	$avgDreamsPerDay	$numMostDreams	$numDreamsToday
Word count	$wordCount	$avgWordCount	$mostWords	$wordCountToday

See also 'dr list-headers -f' and 'dr header-values -f [header]'.
STATS_DISP
    ;;

"edit"|"e")
    [ -z "$1" ] && die "'dr edit' needs arguments. See 'dr help edit' for help."

    # Parse optional arguments to edit.
    doReverse=0
    doShuf=0
    doUseEditor=1
    while getopts rsl opt; do
        case $opt in
        r)
            doReverse=1 ;;
        s)
            doShuf=1 ;;
        l)
            doUseEditor=0 ;;
        esac
    done
    shift $((OPTIND-1))

    # Now compile a list of all the dreams we've specified.
    args=""
    while [ ! -z "$1" ]; do
        if [[ $1 =~ ^[0-9][0-9]*$ ]]
        then
            let num=10#$1  # in case user uses leading zeroes
            printf -v newargs '%05d.dre' "$num"
        else case "$1" in
        "last"|"back"|"l"|"b")
            howMany="$2"
            [ -z "$2" ] && howMany=1
            newargs=$(ls *.dre | tail -n $howMany)
            if [[ "$1" == "back" || "$1" == "b" ]]; then
                newargs=$(echo "$newargs" | head -n 1)
            fi
            [ ! -z "$2" ] && shift # automatic shift handles only one arg
            ;;
        
        "grep"|"g")
            ensure "! -z \"$2\"" "'grep' needs a pattern. (See 'dr help edit' for help.)"
            newargs=$(grep -l "$2" *.dre)
            shift # automatic shift handles only one arg
            ;;

        "random"|"r")
            howMany=$2
            [ -z "$howMany" ] && howMany=1
            newargs=$(ls *.dre | shuf | head -n $howMany | sort)
            ;;

        *) # filename glob
            [[ $(echo "$1" | grep ".dre") ]] && die "Globbing patterns should not include '.dre'. (See 'dr help edit' for help.)"
            newargs="$1.dre"
        esac
        fi  # regex matches

        # Add args parsed to the complete list and proceed. Note that if a type
        # of expression has more than one argument, it's responsible for doing
        # the extra shifts before it finishes.
        args="$args $newargs"
        shift
    done

    # apply option flags
    args=$(echo $args | cat -) # looks like a no-op, but it expands globs
    [ $doShuf -eq 1 ]    && args=$(echo $args | tr ' ' '\n' | shuf)
    [ $doReverse -eq 1 ] && args=$(echo $args | tr ' ' '\n' | tac)

    # sanity check
    [ -z "$args" ] && die "No results."
    for i in $args
    do
        ensure "-f $i" "Matched nonexistent file '$i'; please check your search terms and try again."
    done

    if [ $doUseEditor -eq 1 ]; then
        $EDITOR $args
    else
        echo $args
    fi
    ;;

"last-lucid"|"ll")
    "$EDITOR" $(grep -l 'Lucid:	' *.dre | tail -n 1) ;;

"regenerate-graphs"|"rg")
    scripts/RegeneratePlots.sh ;;

"become-lucid"|"bl")
    echo "Nice try." ;;

"version"|"--version"|"v")
    echo "dr version $MYVERSION" ;;

"help"|"--help"|"h"|"-h"|*)
    if [ "$1" == "edit" ]; then
        usagemsg_edit
    else
        usagemsg
    fi
    ;;
esac

[[ $didpush == 1 ]] && popd
exit 0
