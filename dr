#!/bin/bash
# shellcheck disable=SC2086,SC1117

# %%% dr - Dreamdir utility program
# Copyright (c) 2015-2019 Soren Bjornstad; see LICENSE for details.

##### NOTES ON SHELLCHECK DIRECTIVES #####
# (For some stupid reason there can't be other comments between the shebang and
# the disable directives.)
# 1117: As stated on the official wiki page, this warning has been disabled in
#   the next release "due to being too pedantic".
# 2086: Turn off checks for variable quoting.
#   It's really too bad this has to be turned off, because it catches places
#   where variables really should have been quoted but were not. Unfortunately,
#   it flags passing around command-line arguments and lists of files like
#   "grep 'pattern' $DREAMGLOB" as errors, and as such produces a heap of
#   irrelevant warnings in this script. We could switch to using arrays
#   sometime in the future.


##### CONSTANTS #####
# application version
declare -r MYVERSION="2.0.X-devel"

# matching pattern for dream files
declare -r DREAMGLOB='[0-9][0-9][0-9][0-9][0-9].dre'


##### DOCUMENTATION / HELP MESSAGES #####
# usagemsg()
# Print the usage/help message and exit.
usagemsg() {
    cat <<USAGEMSG
dr - Dreamdir utility program
Copyright (c) 2015-2019 Soren Bjornstad; see LICENSE for details.

Usage: $(basename "$0") <action> [<action arguments>]
There are two types of actions, searches and utilities.

                             SEARCHES
Searches display some information about a subset of dreams. They take an
implied search expression after their other arguments; an empty search
expression selects all dreams. For information about search expressions, type
'$(basename "$0") help search'.

cat [-f]            :: print all content of matching dreams on stdout; if -f,
                       fold lines to a maximum length of 80 characters
dump-headers        :: print headers of matching dreams
edit                :: pass matching dreams as args to \$EDITOR
find                :: show numbers of matching dreams
filename-display    :: print filenames of matching dreams
get-header <header> :: print values of <header> for matching dreams
header-values [-f] <header> :: show a list of all values used for <header>
                       in matching dreams (include frequency if -f specified)
list-headers [-f]   :: list headers used in at least one matching dream
                       (include frequency if -f specified)
word-count          :: show word count of the specified dreams, not
                       including headers
winnow              :: read filenames from stdin and write only those matching
                       this expression to stdout (to create AND queries)

                             UTILITIES
Utilities perform some other action.

act <search action> :: take <search action> on the list of filenames given on
                       stdin; useful for integration with other systems or at
                       the end of a winnow pipeline
help                :: show this usage message
header-replace      :: regex search-and-replace on headers; type
                       '$(basename "$0") help header-replace' for info
new                 :: create a new dream with the next available ID
                       number and open it for editing
regenerate-tags     :: run scripts/vimtags.py to update the Vim tags list
check-validity      :: format sanity check: ensure all dreams have
                       IDs and dates and ID numbers are contiguous
version             :: print version number of this 'dr'

An action can be abbreviated by its initials (e.g., help: h, list-headers: lh).
USAGEMSG
    exit 0
}

# usagemsg_edit()
# Print the help on searching and exit.
usagemsg_edit() {
    cat <<USAGEMSG
                             DR - SEARCHING
$(basename "$0") <action> [<options>] <expr>

Select dreams matching search expression <expr> and take <action>
(available search actions are listed under 'dr help').

                             SEARCH EXPRESSIONS
A search expression is one or more of the following.  If multiple search
expressions are given, each search expression is evaluated in turn and the
results are concatenated.

  * a dream number (leading zeroes are allowed but not required)
  * a range of numbers: 12-18 or -18 (i.e., 1-18) or 12- (i.e., 12-last dream);
    leading zeroes are allowed but not required
  * a Bash globbing pattern for some dream numbers (leading zeroes are required)
  * a[ll]          :: select all dreams
  * b[ack] [<N>]   :: select the dream N positions from the end, inclusive
  * l[ast] [<N>]   :: like 'back', but select all dreams between N and the end
  * d[ate] <op> <date> :: select dreams by date; <op> is 'gt', 'ge', 'lt',
                      'le', 'eq', or 'ne' or the usual symbolic equivalents
                      (>, >=, <, <=, =, !=), and <date> is in YYYY-MM-DD format
  * g[rep] <regex> :: select all dreams matching ERE <regex> anywhere in the
                      file (whether in headers, notes, or text)
  * t[agged] [-f] <header> <hregex> :: select dreams with <header> matching
                      <hregex>; with -f ("full"), select based on a standard
                      ERE on the whole line rather than an hregex
  * r[andom] [<N>] :: select N dreams at random, presenting those selected in
                      numerical order (add -s if random order is desired)

N defaults to 1 if not provided.

A search expression may be entirely blank; in this case all dreams are
selected.  Options are still parsed (see below).

Globbing patterns used in search expressions should be quoted (e.g., to edit
all dreams, use "dr edit '*'" , not "dr edit *").  They will be expanded either
way, but 'dr' can parse a glob more quickly than a long argument list, so
the search will finish faster if you quote the pattern.  Note also that
including '.dre' is optional -- that is, '0100[34]' expands to '01003.dre
01004.dre'.

                             HREGEXES
<hregex>es are Extended Regular Expressions (EREs) that match only within
comma-separated items.  The ^ and $ anchors can be used to match the start and
end of a single item.  For example, with header "Tags: foo, bar baz, foobar":

  REGEX     :: MATCHES
  foo       :: 'foo' & 'foobar'
  bar       :: 'bar' & 'foobar'
  baz       :: 'bar baz'
  az        :: 'bar baz'
  .*baz     :: 'bar baz'
  ^ba.*az   :: 'bar baz'
  ^foobar$  :: 'foobar'
  ^baz$     :: -
  o, ba     :: -
  foo.*baz  :: -

Padding your expression with ^ and $ is often useful; otherwise 'cat' matches
'catalog' and 'duplicate'. If you want to avoid 'catalog' but still get 'cat
food', you can pad with '\\b' (word boundary).

With 'dr find tagged', a dream matches if any comma-separated item matches
the hregex.

With 'dr header-replace', only the specific comma-separated item that matches
is replaced.

                             OPTIONS
The following options may be used with any search expression. They are applied
to the results in this order if several are used:
  -v     :: invert match (show only dreams that do *not* match expression)
  -r     :: reverse the order of returned results
  -s     :: randomize (shuffle) the order of returned results
  -l <N> :: show only the first N results (if N is negative, remove N results
            from the end of the list)

                             EXAMPLES
dr edit 50                    :: edit dream number 50
dr filename-display 006[12]?  :: show the filenames of dreams #610-629
dr edit last 4 890            :: edit the last four dreams and #890
dr dump-headers 20 0[12]01*   :: show headers for dreams #20, #1010-1019,
                                 #2010-2019
dr get-header Tags '*'        :: show the Tags lines of all your dreams
dr edit -s last 6             :: edit the last six dreams in a random order
dr cat -l 6 grep 'foo|bar'    :: print the first six dreams with a line
                                 containing the substring "foo" or "bar"
dr cat date ge 2018-01-01     :: print all dreams from 2018 or later
dr edit -r grep 'XX' back 20  :: edit the dream 20 from the end, then dreams
                                 containing "XX" in reverse numerical order
dr filename-display random 5  :: list the filenames of five random dreams
dr find tagged Places XYZ     :: show numbers of dreams taking place at XYZ
dr edit tagged Tags '^cat$'   :: edit dreams tagged with 'cat', but not
                                 'caterwaul' or 'dedicate'
dr filename-display 610-629 | :: see a list of all the places used in dreams
  dr winnow t Tags 'dog' |       #610-629 that have a tag containing the
  dr act header-values Places    substring 'dog'
dr wc                         :: display a word count of all dreams
dr wc -sl 12 all              :: display the word count of 12 random dreams
dr list-headers -f 500- |     :: show what headers you've used more than 50
  awk '\$1 > 50'                 times (e.g., 'Date', 'Id', 'Tags') in dreams
                                 500 and newer
dr fd tagged People Maud |    :: copy dreams Maud appears in into the
  xargs cp -t maud-dreams        'maud-dreams' folder
USAGEMSG
    exit 0
}

usagemsg_header_replace() {
    cat <<USAGEMSG
                             DR - HEADER-REPLACE
$(basename "$0") header-replace [-f] <header> <find> <replace> [<search-expr>]

In dreams matching <search-expr>, replace instances of <find> in header
<header> with <replace>.  <header> and <replace> are EREs; <find> is
specifically an hregex (see 'help dr search' for more information).

<find> will not match across commas, but it may match and change several tags
separately.  For example, for the header 'Tags: bar, baz', we could find 'ba'
and replace with 'fo' and obtain 'Tags: for, foz', but a search for 'r, b' will
not match anything.

Each comma-separated value is treated as a separate line for matching purposes,
so we can search for '^foobar$' to match only 'foobar' and not 'foobarbaz' in
'Tags: foobar, foobarbaz'.

                             PREVIEWING
Without the -f option, dr produces a preview of the changes your search-and-
replace will make.  Typical output looks like this:

    $ dr header-replace Tags "foo" "quux"
                    === Preview of changes to be applied ===
    01223.dre:
      -foo
      +quux
      =Tags:	quux, bar, baz

    Changes will affect 1 file.
    To make these changes, rerun the command with the '-f' option.

One section will be produced for each dream affected.  The first lines
underneath are a diff between the two sets of values.  The last line shows the
new header line that will be substituted in if you accept the changes.

                             RUNNING
After checking over the preview, rerun the command with the -f option to
actually make the changes.  Naturally, this can be quite dangerous with the
wrong regexes (e.g., a replacement of '.' with 'x' will completely trash all
your headers), so it's wise to make a backup first.  You'll also be required to
confirm interactively that you've double-checked the preview.

(NOTE: If the replace command gets interrupted in the middle, it is possible,
though very unlikely, that one of your dreams will have been deleted; you can
check this by seeing if 'dr check-validity' fails with a missing ID number.  If
this does occur you will find the content in the file 'repl.tmp' in your
dreamdir.)
USAGEMSG
}


##### UTILITY FUNCTIONS #####
# die()
# Print arguments to stderr and exit the shell with the last exit code
# (or 1 if the last exit code is 0).
#
# Arguments:
#     $1 - Message to complain with.
die() {
    ret=$?
    if [ $ret -eq 0 ]; then
        ret=1
    fi
    printf "%b\n" "$@" >&2
    exit $ret
}

# numerize()
# Display some string in singular or plural as appropriate.
#
# Arguments:
# $1 - the number to condition the singular/plural status on
# $2 - the singular form
# $3 - the plural form (optional; if not provided, defaults to singular + 's')
#
# Example:
# $ echo "I think there $(numerize $n "is" "are") $n $(numerize $n "foo") here."
# I think there is 1 foo here.
# I think there are 2 foos here.
numerize() {
    [ -n "$1" ] || die "Invalid arguments given to numerize()"
    [ -n "$2" ] || die "Invalid arguments given to numerize()"
    local num=$1
    local singular=$2
    if [ -z "$3" ]; then
        local plural="$singular"s
    else
        local plural=$3
    fi

    if [ "$num" -ne 1 ]; then
        echo "$plural"
    else
        echo "$singular"
    fi
}

# defileify()
# Given some dream filenames, convert them to comma-separated numbers, with no
# leading zeroes, and print the result.
#
# Arguments:
# (variable number) - the files to process
defileify() {
    sed -e 's/\(^\| \)00*/\1/g' -e 's/\.dre/,/g' -e 's/,$//' <<<"$@"
}

# colorify()
# Given a string, print the string with "syntax highlighting" for dreamdir
# syntax.
#
# Argument:
# $1 - the string to color
colorify() {
    awk -f <(cat - <<ENDSCRIPT
    function pop_stack (stack, len,   item) {
        item = stack[len]
        delete stack[len]
        return item
    }

    function push_stack (stack, item, len) {
        stack[len+1] = item
        return len+1
    }

    BEGIN {
        col_headers = "\033[0;32m"
        col_lucid = "\033[0;34m"
        col_notes = "\033[0;36m"
        col_verbatim = "\033[0;31m"
        col_clear = "\033[0m"

        color_stack[0] = ""
        stack_len = 0
        cur_color = col_clear
        in_backtick = 0
    }

    { UNHANDLED = 1 }

    /:\t/ {
        split(\$0, arr, ":\t")
        printf("%s%s%s:\t%s\n", col_headers, arr[1], col_clear, arr[2])
        UNHANDLED = 0
    }

    UNHANDLED && /^[^\[\]{}\`]*$/ {
        print \$0
        UNHANDLED = 0
    }

    UNHANDLED {
        mlen = length(\$0)
        for (i = 1; i <= mlen; i++) {
            char = substr(\$0, i, 1)
            if (char == "[") {
                stack_len = push_stack(color_stack, cur_color, stack_len)
                cur_color = col_notes
                printf("%s%s", cur_color, char)
            } else if (char == "{") {
                stack_len = push_stack(color_stack, cur_color, stack_len)
                cur_color = col_lucid
                printf("%s%s", cur_color, char)
            } else if (char == "\`" && !in_backtick) {
                stack_len = push_stack(color_stack, cur_color, stack_len)
                cur_color = col_verbatim
                printf("%s%s", cur_color, char)
                in_backtick = 1
            } else if (char == "]") {
                printf("%s", char)
                cur_color = pop_stack(color_stack, stack_len--)
                printf("%s", cur_color)
            } else if (char == "}") {
                printf("%s", char)
                cur_color = pop_stack(color_stack, stack_len--)
                printf("%s", cur_color)
            } else if (char == "\`" && in_backtick) {
                printf("%s", char)
                cur_color = pop_stack(color_stack, stack_len--)
                printf("%s", cur_color)
                in_backtick = 0
            } else {
                printf("%s", char)
            }
        }
        printf("\n")
    }

    END {
        printf("%s", col_clear)
    }
ENDSCRIPT
) </dev/stdin
}

# getrange()
# Given a range of dreams in the form Range ::= Number{*}@Number{*}, print
# a string of the filenames of dreams in that range (inclusive). If one of the
# numbers is missing, the first or last dream in the dreamdir is implied; '@'
# as a range is equivalent to all dreams.
#
# The @ will probably be input as something more sensible like '-'; we just use
# it as an internal separator because it doesn't conflict with command-line
# options.
#
# Called in several places in dreamfind().
#
# Argument:
# $1 - the range to find
#
# Example:
# $ echo "Filename list: $(getrange 4-8)"
# 00004.dre 00005.dre 00006.dre 00007.dre 00008.dre
getrange() {
    [ -n "$1" ] || "Invalid arguments given to getrange()"
    local startat; local endat
    startat=${1%@*}
    endat=${1#*@}
    if [ -z "$startat" ]; then
        dreamfind 1
        startat=$(defileify $args)
    fi
    if [ -z "$endat" ]; then
        dreamfind last
        endat=$(defileify $args)
    fi
    [ -n "$startat" ] || die "No results."
    [ -n "$endat" ] || die "No results."
    seq -f '%05g.dre' "$startat" "$endat"
}

# drwordcount()
# Call an appropriate program to return a word count.
#
# Arguments:
# $1 - "t" for machine-readable summary of all dreams combined
#          (normal lucid notes total)
#      "p" for pretty-printed complete display
# (variable) dream filenames to pass to the word count program
drwordcount() {
    local params
    if [ "$1" = "p" ]; then
        params="-p"
    elif [ "$1" = "t" ]; then
        params="-s"
    else
        die "Illegal arguments to drwordcount()!"
    fi
    shift

    # shellcheck disable=2068
    # :: word splitting on $@ is, in a rare happening, correct
    if [ -x "scripts/bin/drwc" ]; then
        scripts/bin/drwc $params $@
    else
        if [ "$params" = "-p" ]; then
            python2 <<WC_END
import scripts.ddirparse as dp
print dp.getCount("$@".split(' '), asPrettyString=True)
WC_END
        else
            python2 <<WC_END
import scripts.ddirparse as dp
print dp.getCount("$@".split(' '), asString=True)
WC_END
        fi
    fi
}


##### COMPLICATED ROUTINES #####
# dreamfind()
# Parse a search expression. The filenames of matching dreams are placed in the
# variable $args.
#
# This function may be used either to parse user input or to select dreams
# matching some pattern from within the script.
#
# Arguments:
# (variable number) A search expression, as input at the command line.
dreamfind() {
    # Before parsing optional arguments, we have to change the delimiter used
    # for ranges, because getopts isn't smart enough to see that "-20" is a
    # unidirectional range from 1-20, not two arguments "2" and "0".
    # http://unix.stackexchange.com/questions/258512/how-to-remove-a-positional-parameter-from
    for arg; do
        shift
        if [[ $arg =~ ^[0-9]*-[0-9]*$ ]]; then
            newarg="${arg//-/@}"
        else
            newarg="$arg"
        fi
        set -- "$@" "$newarg"
    done

    # Parse optional arguments to edit.
    df_doReverse=0    # global because a user that has to sort the results
    df_doShuf=0       # for further processing has to reapply these filters
    local limit=0
    local invert=0
    OPTIND=0  # if loop doesn't run at all, we need to make sure it's reset
    while getopts :rsl:v opt; do
        case $opt in
        r)
            df_doReverse=1 ;;
        s)
            df_doShuf=1 ;;
        l)
            limit="$OPTARG"
            [[ $limit =~ ^[0-9]+$ ]] || die "'$limit' is not a valid number of dreams to limit your search to."
            ;;
        v)
            invert=1 ;;
        *)
            die "Invalid option (-rslv are valid; see 'dr help search')."
        esac
    done
    shift $((OPTIND-1))

    # No arguments is equivalent to "all".
    if [ -z "$1" ]; then
        # http://stackoverflow.com/questions/13762370/
        # assigning-to-a-positional-parameter
        set -- "all"
    fi

    # Now compile a list of all the dreams we've specified.
    args=""
    local newargs=""
    local howMany=0
    while [ -n "$1" ]; do
        if [[ $1 =~ ^[0-9][0-9]*$ ]]; then
            local num=$((10#$1))
            printf -v newargs '%05d.dre' "$num"
        elif [[ $1 =~ ^[0-9]*@[0-9]*$ ]]; then
            newargs=$(getrange "$1")
        else case "$1" in
        "last"|"back"|"l"|"b")
            local action=$1
            if [[ -n "$2" && $2 =~ ^[0-9]+$ ]]; then
                howMany="$2"
                shift
            else
                howMany=1
            fi
            newargs=$(find $DREAMGLOB | tail -n "$howMany")
            if [[ "$action" = "back" || "$action" = "b" ]]; then
                newargs=$(head -n 1 <<<"$newargs")
            fi
            ;;
        
        "grep"|"g")
            [ -n "$2" ] || die "'grep' needs a pattern. (See 'dr help search' for help.)"
            newargs=$(grep -El "$2" $DREAMGLOB)
            shift
            ;;

        "random"|"r")
            if [[ -n "$2" && $2 =~ ^[0-9]+$ ]]; then
                howMany=$2
                shift
            else
                howMany=1
            fi
            newargs=$(find $DREAMGLOB | shuf | head -n "$howMany" | sort)
            ;;

        "all"|"a")
            newargs=$DREAMGLOB
            ;;

        "date"|"d")
            [ -n "$2" ] || die "oops"
            [ -n "$3" ] || die "oops"
            operator=$2
            dateExpr=$3
            [[ "$dateExpr" =~ [012][0-9][0-9][0-9]-[01][0-9]-[0123][0-9] ]] || die "Invalid date (use YYYY-MM-DD)."
            case $operator in
                'gt'|'>')        awkop='>' ;;
                'lt'|'<')        awkop='<' ;;
                'ge'|'>=')       awkop='>=' ;;
                'le'|'<=')       awkop='<=' ;;
                'eq'|'='|'==')   awkop='==' ;;
                'ne'|'!='|'<>')  awkop='!=' ;;
                *)               die "Invalid operator!" ;;
            esac

            newargs=$(awk "/Date:	/ { if (\$2 $awkop \"$dateExpr\") { print FILENAME } }" $DREAMGLOB)
            shift 2
            ;;

        "tagged"|"t")
            local usage="Usage: dr $action tagged [-f] <header regex> <value regex>"
            [ -n "$2" ] || die "$usage"
            [ -n "$3" ] || die "$usage"
            shift # remove 'tagged' subcommand

            local df_t_full=0
            OPTIND=0
            while getopts :f opt; do
                case $opt in
                f)  df_t_full=1 ;;
                *)  die "Invalid option (-f is valid; see 'dr help search')."
                esac
            done
            shift $((OPTIND-1))

            local header=$1
            local searchpat=$2
            if [ $df_t_full -eq 1 ]; then
                # Treat ^ and $ as the end of the header field. If these are
                # not used, add .* to simulate the substring match you would
                # get if the $header: constraint weren't out front.
                local newsearchpat=$searchpat
                if [ ${searchpat:0:1} = "^" ]
                    then newsearchpat="${searchpat:1}"
                    else newsearchpat='.*'"${searchpat}"
                fi
                if [ ${searchpat: -1} = "$" ]
                    then newsearchpat="${newsearchpat:0: -1}"
                    else newsearchpat="${newsearchpat}"'.*'
                fi
                newargs=$(grep -Em 1 "$header:	$newsearchpat" $DREAMGLOB |
                    sed -e 's/\([0-9]\{5\}\.dre\):.*/\1/')
            else
                # Comma-separated match. The idea here is to replace the
                # delimiters with '@@@@@' (which we can fairly safely assume
                # will not show up in a tag), then change the user's regex to
                # match '@@@@@' as BOL/EOL and not cross it with '.'.
                local pattern
                pattern=$(sed -e 's/[$^]/@@@@@/' -e 's/\$/[$@]/' -e 's/\./[^@]/' <<<"$searchpat")
                newargs=$(grep -m 1 "$header:	" $DREAMGLOB |
                    sed -e "s/$header:	/@@@@@/" -e 's/, /@@@@@/g' -e 's/$/@@@@@/' |
                    grep -E "[0-9]{5}\.dre:.*$pattern" |
                    sed -e 's/\([0-9]\{5\}\.dre\):.*/\1/')
            fi

            # we want to leave one argument since we already shifted away
            # "tagged" and the main loop shifts one argument for the subcommand
            shift
            ;;

        *) # filename glob
            if [[ $1 = *".dre" ]]; then
                newargs="$1"
            else
                newargs="$1.dre"
            fi
        esac
        fi  # regex matches

        # Add args parsed to the complete list and proceed. Note that if a type
        # of expression has arguments, it's responsible for shifting those away
        # before it finishes.
        args="$args $newargs"
        shift
    done

    # apply option flags
    # shellcheck disable=2086,2116
    # :: Yes, this looks dumb. It expands any globs the string contains.
    args=$(echo $args)
    if [ $invert -eq 1 ]; then
        args=$(comm -3 <(find $DREAMGLOB | tr ' ' '\n' | sort) <(tr ' ' '\n' <<<"$args" | sort))
    fi
    [ $df_doReverse -eq 1 ] && args=$(tr ' ' '\n' <<<"$args" | tac)
    [ $df_doShuf -eq 1 ]    && args=$(tr ' ' '\n' <<<"$args"  | shuf)
    [ $limit -ne 0 ]        && args=$(tr ' ' '\n' <<<"$args"  | head -n $limit)

    # sanity check
    [ -z "$args" ] && die "No results."
    for i in $args; do
        [ -f "$i" ] || die "Matched nonexistent file '$i'; please check your search terms and try again.\n(Type 'dr help search' for help.)"
    done
}

# newdream()
# Create a new dream file with the next unused number and a default template
# and open it in the user's editor.
newdream() {
    local today; local lastNum; local newNum
    today=$(date '+%Y-%m-%d')
    lastNum=$(find $DREAMGLOB | sort | tail -n 1 | cut -c 1-5)
    [ -f $lastNum.dre ] || die "Unable to correctly find last dream number. Please ensure no non-dream files in the dreamdir end with '.dre'. (Pulled '$lastNum'.)"
    newNum=$((10#$lastNum + 1))
    printf -v newNum '%05d' "$newNum"

    # http://unix.stackexchange.com/questions/88490/how-do-you-use-output-redirection-in-combination-with-here-documents-and-cat
    cat <<NEWDREAM >"$newNum.dre" 2>&1
Id:	$newNum
Date:	$today
Time:	
Title:	
People:	
Places:	
Tags:	


NEWDREAM
    cp "$newNum.dre" "/tmp/$newNum.dre"

    if [ "$EDITOR" = "vim" ]; then
        # use vim's option to place the cursor on the last line
        vim "$newNum.dre" +
    else
        "$EDITOR" "$newNum.dre"
    fi
    if diff "/tmp/$newNum.dre" "$newNum.dre" > /dev/null 2>&1; then
        echo "Deleting unmodified dream file."
        rm "$newNum.dre"
    else
        chmod 600 "$newNum.dre" # dreams default to 600 for basic privacy
    fi
    rm "/tmp/$newNum.dre"
}

# header_replace()
# Perform a search-and-replace in headers or other tags. Accepts $@ as arguments.
header_replace() {
    local usageMsg
    usageMsg="Usage: $(basename "$0") header-replace [-f] <header> <search> <replace> <search-expr>\nType 'dr help header-replace' for details."
    [[ -n "$1" && -n "$2" && -n "$3" ]] || die "$usageMsg"
    [[ "$2" =~ @ || "$3" =~ @ ]] && die "Sorry, at-signs (@) are not valid in search/replace regexes."

    if [ "$1" = "-f" ]; then
        local doChange=1
        shift
    else
        local doChange=0
    fi

    local header="$1"
    local searchpat="$2"
    local replpat="$3"
    shift 3

    # Since the replace loop is rather expensive, compile a list of dreams that
    # both match our search-expr and include the <search> hregex, and look only
    # at those.
    dreamfind "$@"
    local affectOnlyDreams="$args"
    dreamfind tagged "$header" "$searchpat"
    args=$(comm -12 <(tr ' ' '\n' <<<"$affectOnlyDreams") \
                    <(tr ' ' '\n' <<<"$args"))

    # If we're actually making changes, confirm that we really want to.
    local numToChange
    if [ $doChange -eq 1 ]; then
        numToChange=$(wc -w <<<"$args")
        echo "You are about to apply a search-and-replace that will affect" \
        "$numToChange $(numerize "$numToChange" dream)."
        if [ $numToChange -ge 50 ]; then
            echo -e "\e[1;31mThat looks like quite a few dreams.\e[0m"
        fi
        echo "If this doesn't sound right, please check the results without -f first!"
        read -rp "Do you wish to continue (y/n)? " doCont
        if [ "$doCont" != "y" ]; then
            exit 0
        fi
    else
        echo "                    === Preview of changes to be applied ==="
    fi

    local numAffected=0
    for filename in $args; do
        local headerline; local oldtags; local newtags; local diffs
        headerline=$(grep -m 1 "$header:	" "$filename")
        oldtags=$(sed -e "s/$header:	//" -e 's/, /\n/g' <<<"$headerline")
        newtags=$(sed -re "s@$searchpat@$replpat@g" <<<"$oldtags")
        diffs=$(diff -u <(echo "$oldtags") <(echo "$newtags") | grep '^[+-]' | sed -e '1,2d' -e 's/^/  /')

        if [ -z "$diffs" ]; then
            continue
        fi

        local replwith
        replwith="$header:	$(tr '\n' ',' <<<"$newtags" | sed -e 's/,/, /g' -e 's/, $//')"
        if [ $doChange -eq 1 ]; then
            sed -e "s@$headerline@$replwith@" "$filename" > repl.tmp
            rm "$filename"
            mv repl.tmp "$filename"
            echo "$filename modified"
        else
            echo -e "$filename:\n$diffs\n  =$replwith\n"
        fi
        numAffected=$((numAffected+1))
    done

    if [ $doChange -eq 1 ]; then
        echo "Changed $numAffected $(numerize $numAffected file)."
    else
        echo "Changes will affect $numAffected $(numerize $numAffected file)."
        echo "To make these changes, rerun the command with the '-f' option."
    fi
}

# validate_dreamdir()
# Check to see if our dreamdir's format is okay.
validate_dreamdir() {
    # set up temp file for checking id and date headers
    local tempfile="/tmp/dreamgrep" # contains list of dream files
    [ ! -e $tempfile ] || die "Please check & remove existing temp file $tempfile and try again."
    find . -maxdepth 1 -name "$DREAMGLOB" | sort | cut -c 3- > "$tempfile"

    # check for id problems
    local checkFailedFor
    if checkFailedFor=$(grep -l 'Id:	[0-9]\{5\}' $DREAMGLOB | sort | diff - "$tempfile"); then
        echo "ID value check...OK"
    else
        echo "ID value check...FAILED"
        echo "The files listed in the following diff have missing or incomplete"
        echo "Id headers:"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi

    # check for date problems (similar -- consider a function)
    if checkFailedFor=$(grep -l 'Date:	[12][901][0-9]\{2\}-[01][0-9]-[0123][0-9]' $DREAMGLOB | sort | diff - "$tempfile"); then
        echo "Date check...OK"
    else
        echo "Date check...FAILED"
        echo "The files listed in the following diff have missing or invalid"
        echo "Date headers, or represent implausible or impossible dates."
        echo "(Note: dates must be in YYYY-MM-DD format.)"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi

    # check for ID continuity
    checkFailedFor="$(sed -re 's|\./([0-9]{5})\.dre|\1|' < "$tempfile" |
        awk 'BEGIN { var = 1; } { if (var != $1+0) print $1; var++; }')" 
    if [ -z "$checkFailedFor" ]; then
        echo "ID continuity...OK"
    else
        echo "ID continuity...FAILED"
        echo "A number was skipped before the following files:"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi

    rm "$tempfile"
    echo "All tests succeeded."
}


##### MAIN SCRIPT #####
# If DREAMDIR environment variable is set and we're not already in $DREAMDIR,
# change directory into it until the end of the script.
if [[ -n "$DREAMDIR" && "$PWD" != "$DREAMDIR" && ! -f ".dreamdir" ]]; then
    if ! cd "$DREAMDIR"; then
        echo "ERROR: The current directory is not a dreamdir and the DREAMDIR"
        echo "environment variable is set to an invalid directory"
        echo "($DREAMDIR). Exiting."
        exit 1
    fi
fi

# Confirm that we've ended up in a dreamdir.
[ -f .dreamdir ] || die "Please run this script from a dreamdir, or set the environment variable \$DREAMDIR to the path to your dreamdir."

# Figure out what action we're going to do and jump to appropriate code.
[ -z "$1" ] && usagemsg
action="$1"
shift # arguments to actions start at $1

case "$action" in
"new"|"n")
    newdream
    ;;

"edit"|"e")
    dreamfind "$@"
    "$EDITOR" $args
    ;;

"find"|"f")
    dreamfind "$@"
    # remove leading zeroes and '.dre' for display, add separator commas
    results="$(defileify $args)"
    numMatches="$(wc -w <<<"$results")"
    echo -e "$numMatches $(numerize $numMatches "match" "matches"): [$results]"
    ;;

"filename-display"|"fd")
    dreamfind "$@"
    echo "$args"
    ;;

"winnow"|"w")
    read -r toFilter
    [ -z "$toFilter" ] && die "'dr winnow' requires a list of filenames on stdin, usually piped from\n'winnow' or 'filename-display'. (Type 'dr help' for help.)"
    for i in $toFilter; do
        [ -f "$i" ] || die "'$i' is not a dream filename.\nDid you forget to start your pipeline with 'filename-display'?\n(Type 'dr help' for help.)"
    done

    dreamfind "$@"
    results=$(comm -12 <(tr ' ' '\n' <<<"$toFilter" | sort) <(tr ' ' '\n' <<<"$args" | sort))
    # since comm needs sorted content, we have to reapply the order changes
    [ $df_doReverse -eq 1 ] && results=$(tac <<<"$results")
    [ $df_doShuf -eq 1 ]    && results=$(shuf <<<"$results")
    echo "$results"
    ;;

"get-header"|"gh")
    [ -n "$1" ] || die "Usage: $(basename "$0") get-header <header> <search-expr>"
    getHeader=$1
    shift
    dreamfind "$@"
    grep "$getHeader:	" $args | sed -e "s/$getHeader:	\(.*\)/\1/" -e 's/^00*\([0-9]\+\).dre:/\1: /'
    ;;

"dump-headers"|"dh")
    # shellcheck disable=SC2016
    # :: Indeed, expressions don't expand in single quotes. That's the point!
    mainCmd='awk '\''{ if (!$0) { print ""; nextfile }; print $0; }'\'' $args'

    # add color if running in an interactive terminal
    [ -t 1 ] && highlightCmd='| colorify'

    # evaluate pipeline with appropriate parts
    dreamfind "$@"
    eval "$mainCmd $highlightCmd"
    ;;

"cat"|"c")
    # shellcheck disable=SC2016
    # :: Indeed, expressions don't expand in single quotes. That's the point!
    # See https://unix.stackexchange.com/a/212949 on this funky paste usage.
    mainCmd=': | paste -sd "\n" $(sed $"s/\s/ - - /g" <<< $args)'

    # add color if running in an interactive terminal
    [ -t 1 ] && highlightCmd='| colorify'

    # fold if requested
    if [ "$1" = "-f" ]; then
        foldCmd="| fold -s"
        shift
    fi

    # evaluate pipeline with appropriate parts
    dreamfind "$@"
    eval "$mainCmd $highlightCmd $foldCmd"
    ;;

"list-headers"|"lh")
    if [ "$1" = "-f" ]; then
        showFreq=1
        shift
    else
        showFreq=0
    fi
    dreamfind "$@"
    results=$(grep -h '^.*:	' $args | sed -e 's/^\(.*\):	.*$/\1/' | sort)
    if [ $showFreq -eq 1 ]; then
        uniq -c <<<"$results" | sort -b -k 1rn -k 2
    else
        uniq <<<"$results"
    fi
    ;;

"header-values"|"hv")
    if [ "$1" = "-f" ]; then
        showfreq=1
        shift
    else
        showfreq=0
    fi
    [ -n "$1" ] || die "Please specify a header type, like '$(basename "$0") header-values Tags'."
    header="$1"
    shift
    dreamfind "$@"

    results=$(grep "$header:	" $args | sed -e 's/.*:	//' -e 's/, /\n/g' | sort)
    if [ $showfreq -eq 1 ]; then
        uniq -c <<<"$results" | sort -b -k 1rn -k 2
    else
        uniq <<<"$results"
    fi
    ;;

"header-replace"|"hr")
    header_replace "$@"
    ;;

"check-validity"|"cv")
    validate_dreamdir
    ;;

"word-count"|"wc")
    dreamfind "$@"
    drwordcount "p" "$args"
    ;;

"regenerate-tags"|"rt")
    scripts/vimtags.py ;;

"act"|"a")
    [ -n "$1" ] || die "Usage: [chain of piped dr commands] | dr act <search action>"
    input=$(cat <&0)
    [ -n "$input" ] || die "No data received. (Usage: [chain of piped dr commands or list of filenames] | dr act <search action>)"
    if [ "$1" = "edit" ]; then
        # Work around broken terminal when stdin is being redirected, as
        # recommended in the xargs man page and, e.g.:
        # https://github.com/sitaramc/map/issues/1
        "$0" "$@" $input </dev/tty
    else
        "$0" "$@" $input
    fi
    ;;

"become-lucid"|"bl")
    echo "Nice try." ;;

"version"|"--version"|"v")
    echo "dr version $MYVERSION" ;;

"help"|"--help"|"h"|"-h"|*)
    case $1 in
        "search"|"s"|"edit"|"find")
            usagemsg_edit ;;
        "header-replace"|"hr")
            usagemsg_header_replace ;;
        *)
            usagemsg ;;
    esac
    ;;
esac
