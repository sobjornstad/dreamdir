#!/bin/bash
# %%% dr - Dreamdir utility program
# Copyright (c) 2015-2016 Soren Bjornstad; see LICENSE for details.

# application version
MYVERSION="0.3"

##### DOCUMENTATION / HELP MESSAGES #####
# usagemsg()
# Print the usage/help message and exit.
usagemsg() {
    cat <<USAGEMSG
dr - Dreamdir utility program
Copyright (c) 2015-2016 Soren Bjornstad; see LICENSE for details.

Usage: `basename $0` <action> [<action arguments>]
An action can be abbreviated by its initials (e.g., help: h, list-headers: lh).

                             ACTIONS
help                           :: show this usage message
new                            :: create a new dream with the next available ID
                                  number and open it for editing
edit <search-expr>             :: edit dreams matching an expression
find <search-expr>             :: show dream numbers matching an expression
filename-display <search-expr> :: show dream filenames matching an expression
setdiff <search-expr>          :: read filenames from stdin and XOR them with
                                  the results of another query
winnow <search-expr>           :: read filenames from stdin and AND them with
                                  the results of another query
list-headers [-f]              :: list headers used in at least one dream (with
                                  frequency if -f specified)
header-values [-f] <header>    :: show a list of all values used for <header> in
                                  any dream (include frequency if -f)
header-replace                 :: regex search-and-replace on headers; type
                                  '`basename $0` help header-replace' for info
last-lucid                     :: edit the dream with the highest number that
                                  has a Lucid header
cat [<file>]                   :: concatenate all dream files to form a single
                                  output stream, written to stdout or <file>
regenerate-graphs              :: run scripts/RegeneratePlots.sh to make graphs
stats                          :: display dream statistics
validate                       :: format sanity check: ensure all dreams have
                                  IDs and dates and ID numbers are contiguous

Type '`basename $0` help search' for information about <search-expr>s.
USAGEMSG
    exit 0
}

# usagemsg_edit()
# Print the help on searching and exit.
usagemsg_edit() {
    cat <<USAGEMSG
                             DR - SEARCHING
`basename $0` <edit|find|filename-display|setdiff|winnow> [<options>] <expr>

Select dreams matching search expression <expr> and:
  e[dit] - pass their filenames as arguments to \$EDITOR
  f[ind] - print a list of dream numbers
  f[ilename-]d[isplay] - print a list of dream filenames
  s[etdiff] - read filenames from stdin, print dreams present in stdin but not
      query, and vice versa
  w[innow] - read filenames from stdin, remove non-matches

                             SEARCH EXPRESSIONS
A search expression is one or more of the following (implicitly ORed together):
* a dream number (leading zeroes allowed but not required)
* a shell globbing pattern for some dream numbers (leading zeroes required)
* b[ack] [<N>]   :: select the dream N positions from the end, inclusive
* l[ast] [<N>]   :: like 'back', but select all dreams between N and the end
* g[rep] <regex> :: select all dreams matching ERE <regex> anywhere in the file
                    (whether in headers, notes, or text)
* t[agged] <header> <hregex> :: select dreams with <header> matching <hregex>
* r[andom] [<N>] :: select N dreams randomly from your dreamdir, in numerical
                    order (add -s if desired)

N defaults to 1 if not provided.

                             HREGEXES
<hregex>es are EREs matched only within comma-separated items. For instance,
with the header "Tags: foo, bar baz":
  REGEX     :: MATCHES?
  foo       :: yes
  bar       :: yes
  baz       :: yes
  az        :: yes
  .*baz     :: yes
  ba.*az    :: yes
  o, ba     :: no
  foo.*baz  :: no
You may want to consider padding your regex with '\\b' on either side to
require full-word matches; otherwise 'cat' matches 'catalog' and 'duplicate.'

                             OPTIONS
The following options may be used with any search expression:
  -r: Reverse the order of returned results.
  -s: Randomize (shuffle) the order of returned results.

                             EXAMPLES
dr edit 50                    :: edit dream number 50
dr filename-display 006[12]?  :: show the filenames of dreams #610-629
dr edit last 4 890            :: edit the last four dreams and #890
dr find 20 0[12]01*           :: list dream numbers #20, #1010-1019, #2010-2019
dr edit -s last 6             :: edit the last six dreams in a random order
dr find grep 'foo|bar'        :: list dream numbers with a line containing the
                                 substring "foo" or "bar"
dr edit -r grep 'XX' back 20  :: edit the dream 20 from the end, then dreams
                                 containing "XX" in reverse numerical order
dr filename-display random 5  :: display the filenames of five random dreams
dr edit tagged People Maud    :: edit dreams in which Maud appeared
dr edit tagged Tags '\\bcat\\b' :: display dreams tagged with 'cat', but not
                                 'caterwaul' or 'dedicate'
dr fd 006[12]? |              :: display filenames for dreams #610-629 that
  dr winnow tagged Tags 'dog'    are also tagged with 'dog'              
dr fd t Tags '\bcat\b' |      :: show dreams that are not tagged 'cat' but
  dr setdiff grep '\bcat\b'      do use the word 'cat' somewhere else
USAGEMSG
    exit 0
}

usagemsg_header_replace () {
    cat <<USAGEMSG
                             DR - HEADER-REPLACE
`basename $0` header-replace [-f] <header> <find> <replace> [<filenames...>]

In <filenames> or the entire dreamdir, replace instances of <find> in header
<header> with <replace>. <Find>, <header>, and <replace> are EREs.

<find> will not match across multiple comma-separated values, but it may match
and change several tags separately. For example, for the header
'Tags: bar, baz', we could find 'ba' and replace with 'fo' and obtain
'Tags: for, foz', but a search for 'r, b' will not match anything.

Each comma-separated value is considered a separate line, so we can search for
'^foobar$' to match only the entire tag 'foobar' and not, say, 'foobarbaz'.

<find> and <replace> should not contain pipe characters (|).

                             PREVIEWING
Without the -f option, dr produces a preview of the changes your search-and-
replace will make. Typical output looks like this:

    $ dr header-replace Tags "foo" "quux"
    ** Running search-and-replace on all dreams. **

    01223.dre:
      -foo
      +quux
      =Tags:	quux, bar, baz

    Changes will affect 1 file.

One section will be produced for each dream affected. The first lines
underneath are a diff between the two sets of values. The last line shows the
new header line that will be substituted in if you accept the changes.

                             RUNNING
After checking over the preview, rerun the command with the -f option to
actually make the changes. Naturally, this can be quite dangerous with the
wrong regexes (e.g., a replacement of '.' with 'x' will completely trash all
your headers), so it's wise to make a backup first. You'll also be required to
confirm interactively that you've double-checked the preview.

(NOTE: If the replace command gets interrupted in the middle, it is possible,
though very unlikely, that one of your dreams will have been deleted; you can
check this by seeing if 'dr validate' fails with a missing ID number. If this
does occur you will find the content in the file 'repl.tmp' in your dreamdir.)
USAGEMSG
}

##### UTILITY FUNCTIONS #####
# ensure()
# Make sure a condition necessary for script execution is true.
#
# Arguments:
#     $1 - an argument to `test`
#     $2 - a message to display if the test fails
#	  $3 - (optional, default 1) exit status to return if the test fails
# State change & return:
#     If the test evaluates non-zero, the script prints $2 and exits with
#     status $3 (or 1). Else, control returns to the caller.
ensure() {
    eval "test $1"
    if [ $? -ne 0 ]
    then
        if [ -z "$3" ]; then
            exitval=1
        else
            exitval=$3
        fi
        echo -e "$2"
        exit $exitval
    else
        return 0
    fi
}

# die()
# Unconditionally exit the shell with status 1 after printing the given error.
#
# Arguments:
#     $1 - Message to complain with.
die() {
    echo "$1"
    exit 1
}

# don't display the directory stack on push/pop
pushd () {
    command pushd "$@" > /dev/null
}
popd () {
    command popd "$@" > /dev/null
}

##### COMPLICATED ROUTINES #####
# dreamfind()
# Parse a search-expr; called by find/edit/winnow/etc to do the dirty
# filtering work.
dreamfind() {
    # Parse optional arguments to edit.
    doReverse=0
    doShuf=0
    while getopts rs opt; do
        case $opt in
        r)
            doReverse=1 ;;
        s)
            doShuf=1 ;;
        esac
    done
    shift $((OPTIND-1))

    # Now compile a list of all the dreams we've specified.
    args=""
    while [ ! -z "$1" ]; do
        if [[ $1 =~ ^[0-9][0-9]*$ ]]
        then
            let num=10#$1  # in case user uses leading zeroes
            printf -v newargs '%05d.dre' "$num"
        else case "$1" in
        "last"|"back"|"l"|"b")
            howMany="$2"
            [ -z "$2" ] && howMany=1
            newargs=$(ls *.dre | tail -n $howMany)
            if [[ "$1" == "back" || "$1" == "b" ]]; then
                newargs=$(echo "$newargs" | head -n 1)
            fi
            [ ! -z "$2" ] && shift # automatic shift handles only one arg
            ;;
        
        "grep"|"g")
            ensure "! -z \"$2\"" "'grep' needs a pattern. (See 'dr help search' for help.)"
            newargs=$(grep -El "$2" *.dre)
            shift # automatic shift handles only one arg
            ;;

        "random"|"r")
            howMany=$2
            [ -z "$howMany" ] && howMany=1
            newargs=$(ls *.dre | shuf | head -n $howMany | sort)
            ;;

        "tagged"|"t")
            usage="Usage: dr edit tagged <header regex> <value regex>"
            ensure "! -z \"$2\"" "$usage"
            ensure "! -z \"$3\"" "$usage"
            header="$2"
            pattern=$(echo "$3" | sed -e 's/\./[^@]/')
            newargs=$(grep -m 1 "$header:	" *.dre | sed -e "s/$header:        //" | sed -e 's/, /@@@@@/g' | grep -E "$pattern" | sed -e 's/\([0-9]\{5\}\.dre\):.*/\1/')
            shift; shift
            ;;

        *) # filename glob
            if [[ $(echo "$1" | grep ".dre") ]]; then
                newargs="$1"
            else
                newargs="$1.dre"
            fi
            # If a term ends in "*", then we get '.dre' in perfectly correct
            # globs. Actually the user would do well to quote the expression,
            # as expanding it later makes the search run noticeably faster.
            #&& die "Globbing patterns should not include '.dre'. (See 'dr help search' for help.)"
        esac
        fi  # regex matches

        # Add args parsed to the complete list and proceed. Note that if a type
        # of expression has arguments, it's responsible for shifting those away
        # before it finishes.
        args="$args $newargs"
        shift
    done

    # apply option flags
    args=$(echo $args | cat -) # looks like a no-op, but it expands globs
    [ $doShuf -eq 1 ]    && args=$(echo $args | tr ' ' '\n' | shuf)
    [ $doReverse -eq 1 ] && args=$(echo $args | tr ' ' '\n' | tac)

    # sanity check
    [ -z "$args" ] && die "No results."
    for i in $args
    do
        ensure "-f $i" "Matched nonexistent file '$i'; please check your search terms and try again."
    done
}

# validate_dreamdir()
# Check to see if our dreamdir's format is okay. Extracted from the main case
# statement purely because it's long and makes the script harder to read.
validate_dreamdir() {
    # set up temp file for checking id and date headers
    tempfile="/tmp/dreamgrep" # contains list of dream files
    ensure "! -e $tempfile" "Please check & remove existing temp file $tempfile and try again."
    ls *.dre | sort > "$tempfile"

    # check for id problems
    checkFailedFor=$(grep -l 'Id:	[0-9]\{5\}' *.dre | sort | diff - "$tempfile")
    if [ $? == 0 ]; then
        echo "ID value check...OK"
    else
        echo "ID value check...FAIL"
        echo "The files listed in the following diff have missing or incomplete"
        echo "Id headers:"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi

    # check for date problems (similar -- consider a function)
    checkFailedFor=$(grep -l 'Date:	[12][901][0-9]\{2\}-[01][0-9]-[0123][0-9]' *.dre | sort | diff - "$tempfile")
    if [ $? == 0 ]; then
        echo "Date check...OK"
    else
        echo "Date check...FAIL"
        echo "The files listed in the following diff have missing or invalid"
        echo "Date headers, or represent implausible or impossible dates."
        echo "(Note: dates must be in YYYY-MM-DD format.)"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi
    rm "$tempfile"

    # check for ID continuity
    # works with Python 2 & 3 -- check dual compatibility after changes
    python <<PYTH_ID_CHECK
import os, sys
listing = sorted(os.listdir('.'))
listing = filter(lambda i: i.endswith('.dre'), listing)
nums = []
for i in listing:
    try:
        nums.append(int(i))
    except ValueError:
        # not a dream file, but auxiliary of some kind
        continue

lastnum = 0
for i in nums:
    if i != lastnum+1:
        print("ID continuity check...FAIL")
        print("Failure was on ID %i, not continuous with previous ID %i." % (
              i, lastnum))
        sys.exit(1)
    else:
        lastnum = i
print("ID continuity check...OK")
sys.exit(0)
PYTH_ID_CHECK
    if [ $? != 0 ]; then
        exit 1
    fi

    echo "All tests succeeded."
}

# stats_display()
# Calculate and display textual statistics.
stats_display() {
    echo "Crunching the latest numbers for you, just a moment..."
    colOn='[1;34m'
    colOff='[0m'

    today=$(date '+%Y-%m-%d')
    filenamesToday=$(grep -l "Date:	$today" *.dre)
    if [ ! -z "$filenamesToday" ]; then
        dreamsToday=$(echo $filenamesToday | sed -e 's/\.dre'//g | sed -e 's/ 0*/ /g' | sed -e 's/^0*//') # NOT very clean.
        numDreamsToday=$(echo $dreamsToday | wc -w)
        dreamsTodayDisp=$(echo $dreamsToday | sed -e 's/ /, /g')
        lucidsToday=$(grep 'Lucid:	' $filenamesToday | wc -l)
        wordCountToday=$(wc -w $filenamesToday | tail -n 1 | sed -e 's/^ *//' | cut -d ' ' -f 1)
        if [ -f $wordCountToday ]; then
            # there was only one dream and no "total" line, so we pulled out the wrong thing
            wordCountToday=$(wc -w $filenamesToday | cut -d ' ' -f 1)
        fi
    fi

    numDreams=$(ls *.dre | wc -l)
    wordCount=$(wc *.dre -w | tail -n 1 | cut -d ' ' -f 2)
    avgWordCount=$((wordCount / numDreams))
    dateStats=$(python2 <<PYTH_DATEFREQ
# OUTPUT FORMAT:
# <number of dates recorded> <earliest date> <latest date> <date with most dreams> <how many that was>
import scripts.ddirparse as dp
dp.setDreamdir("$PWD")
dateattrs = dp.getAttribForAllDreams('Date')
dates = [i.split('\t')[1] for i in dateattrs.values()]
freqs = {}
for date in dates:
    freqs[date] = freqs.get(date, 0) + 1
keyList = freqs.keys()
print len(keyList),
print min(keyList),
print max(keyList),
# create list of keys sorted by the order of their values, min to max
byFreq = sorted(keyList, cmp=lambda a,b: cmp(freqs[a],freqs[b]))
print byFreq[-1],       # most number of dreams
print freqs[byFreq[-1]] # how many?
PYTH_DATEFREQ
)
    mostWordsDay=$(python2 <<PYTH_MOSTWORDS
# Getting acceptable performance here requires unfolding some possible
# functions and abstractions into this (nevertheless simple enough) loop.
# TODO: This should be a function in scripts.ddirparse, I can think of tons of
# other good things to do with this, like graphing and printing a table.
import scripts.ddirparse as dp
dp.setDreamdir("$PWD")
wcs = {}
for f in dp.allDreamfiles():
    date = None
    counting = False
    for line in f:
        textline = line.strip()
        if counting:
            wcs[date] += len(textline.split())
        else:
            if textline.startswith('Date:\t'):
                date = textline.split(':\t')[1].strip()
            elif not textline:
                # end of headers, start counter
                counting = True
                if date not in wcs:
                    wcs[date] = 0
# create list of keys sorted by the order of their values, max to min
wcOrder = sorted(wcs.keys(), cmp=lambda a,b: cmp(wcs[b],wcs[a]))
print wcOrder[0], wcs[wcOrder[0]], # # of dreams, date of it
print len(dp.getDreamsTagged('Date', wcOrder[0])) # how many dreams
PYTH_MOSTWORDS
)
    datesRecorded=$(echo "$dateStats" | cut -d ' ' -f 1)
    avgDreamsPerDay=$(echo "scale=2; $numDreams / $datesRecorded" | bc -q)
    earliestDate=$(echo "$dateStats" | cut -d ' ' -f 2)
    latestDate=$(echo "$dateStats" | cut -d ' ' -f 3)
    mostDreamsDate=$(echo "$dateStats" | cut -d ' ' -f 4)
    numMostDreams=$(echo "$dateStats" | cut -d ' ' -f 5)

    mostWordsOnDay=$(echo "$mostWordsDay" | cut -d ' ' -f 1)
    mostWords=$(echo "$mostWordsDay" | cut -d ' ' -f 2)
    dreamsInMostWordsDay=$(echo "$mostWordsDay" | cut -d ' ' -f 3)
    mostWordsDream=$(wc -w *.dre | sort -n | sed -e '$ d' | tail -n 1)
    mostWordsDreamNum=$(echo "$mostWordsDream" | sed -e 's/^ *[0-9]\+ 0*\([0-9]\+\).dre$/\1/')
    mostWordsDreamCount=$(echo "$mostWordsDream" | sed -e 's/^ *\([0-9]\+\).*/\1/')

    lucidFilenames=$(grep -l 'Lucid:	' *.dre)
    numLucids=$(echo $lucidFilenames | wc -w) # -w: $() collapses \n to space
    percentLucid=$(echo "scale=2; 100 * $numLucids / $numDreams" | bc -q)
    totalLucidWordCount=$(wc -w $lucidFilenames | tail -n 1 | cut -d ' ' -f 2)
    avgLucidWordCount=$((totalLucidWordCount / numLucids))
    percentLucidWordCount=$(echo "scale=2; 100 * $totalLucidWordCount / $wordCount" | bc -q)
    daysRecordedLds=$(python2 <<PYTH_DAYS_LDS
# Output format: <days with recorded LDs>
import scripts.ddirparse as dp
dp.setDreamdir("$PWD")
lucids = dp.getDreamsTagged('Lucid', '')
allDates = dp.getAttribForAllDreams('Date')
allDates = {k: v.split('\t')[1] for k,v in allDates.iteritems()}
# Use a dictionary to make future expansion to frequency, etc., easier
lucidDays = {}
for i in lucids:
    lucidDays[allDates[i]] = lucidDays.get(allDates[i], 0) + 1
print len(lucidDays)
PYTH_DAYS_LDS
)
    percentDaysRecordedLds=$(echo "scale=2; 100 * $daysRecordedLds / $datesRecorded" | bc -q)

# Consider, inserting commas into a number:
# echo "$number" | rev | sed 's/\([0-9][0-9][0-9]\)\([0-9]\)/\1,\2/g' | rev

echo -e "${colOn}Today$colOff"
echo -e "Today: $today"
if [ -z "$filenamesToday" ]; then
    echo -e "No dreams recorded today.\n"
else
    echo -e "Dreams recorded today: $numDreamsToday ($dreamsTodayDisp)"
    echo -e "Lucid dreams recorded today: $lucidsToday"
    echo -e "Total word count today: $wordCountToday\n"
fi
cat <<STATS_DISP
${colOn}Recall and recording$colOff
Total dreams: $numDreams
Days with recorded dreams: $datesRecorded
Average dreams per recorded day: $avgDreamsPerDay
Date range: $earliestDate – $latestDate
Day with most dreams: $mostDreamsDate ($numMostDreams)
Total word count: $wordCount
Average words per dream: $avgWordCount
Day with highest word count: $mostWordsOnDay ($mostWords words over $dreamsInMostWordsDay dreams)
Single dream with highest word count: #$mostWordsDreamNum ($mostWordsDreamCount words)

${colOn}Lucidity$colOff
Total lucid dreams: $numLucids
Percentage lucid: $percentLucid%
Days with recorded LDs: $daysRecordedLds
Percentage recorded days with at least one LD: $percentDaysRecordedLds%
Total lucid word count: $totalLucidWordCount
Average words per lucid dream: $avgLucidWordCount
Percentage of words in lucid dreams: $percentLucidWordCount%

${colOn}Table summary${colOff}
		Total	Avg	Max/Day	Today
# of dreams	$numDreams	$avgDreamsPerDay	$numMostDreams	$numDreamsToday
Word count	$wordCount	$avgWordCount	$mostWords	$wordCountToday

See also 'dr list-headers -f' and 'dr header-values -f [header]'.
STATS_DISP
}


##### MAIN SCRIPT #####
# If DREAMDIR environment variable is set and we're not already in $DREAMDIR,
# change directory into it until the end of the script.
didpush=0
oldpwd="$PWD" # if we need to know where the user is running the script from
if [[ ! -z "$DREAMDIR" && "$PWD" != "$DREAMDIR" && \
      ! -d scripts && ! -d graphs && ! -f dr ]]; then
    didpush=1
    pushd "$DREAMDIR"
    if [[ $? != 0 ]]; then
        echo "ERROR: The current directory is not a dreamdir and the DREAMDIR"
        echo "environment variable is set to an invalid directory"
        echo "($DREAMDIR). Exiting."
        exit 1
    fi
fi

# Confirm that we've ended up in a dreamdir.
error="Please run this script from a dreamdir, or set the environment\n"\
"variable \$DREAMDIR to the path to your dreamdir."
ensure '-d scripts' "$error"
ensure '-d graphs'  "$error"
ensure '-f dr'      "$error"

# Figure out what action we're going to do and jump to appropriate code.
[ -z "$1" ] && usagemsg
action="$1"
shift # arguments to actions start at $1

case "$action" in
"new"|"n")
    oldUmask=$(umask)
    umask 0177 # dreams default to 600 for basic privacy
    today=$(date '+%Y-%m-%d')
    lastNum=$(ls *.dre | sort | tail -n 1 | cut -c 1-5)
    ensure "-f $lastNum.dre" "Unable to correctly find last dream number. Please ensure no non-dream files in the dreamdir end with '.dre'. (Pulled '$lastNum'.)"
    let newNum=10#$lastNum+1
    printf -v newNum '%05d' "$newNum"
    echo -e "Id:\t$newNum"   > $newNum.dre
    echo -e "Date:\t$today" >> $newNum.dre
    echo -e "Time:\t"       >> $newNum.dre
    echo -e "Tags:\t"       >> $newNum.dre
    echo -e "\n"            >> $newNum.dre
    cp $newNum.dre /tmp
    if [ "$EDITOR" == "vim" ]; then
        # use vim's option to place the cursor on the last line
        vim $newNum.dre +
    else
        "$EDITOR" $newNum.dre
    fi
    diff /tmp/$newNum.dre $newNum.dre > /dev/null 2>&1
    if [ $? == 0 ]; then
        echo "Deleting unmodified dream file."
        rm "$newNum.dre"
    fi
    rm "/tmp/$newNum.dre"
    umask $oldUmask
    ;;

"edit"|"e")
    [ -z "$1" ] && die "'dr edit' needs arguments. See 'dr help search' for help."
    dreamfind "$@"
    $EDITOR $args
    ;;

"find"|"f")
    [ -z "$1" ] && die "'dr edit' needs arguments. See 'dr help search' for help."
    dreamfind "$@"
    results=$(echo $args | sed -e 's/\.dre 00*/, /g' | sed -e 's/^00*/[/' | sed -e 's/\.dre$/]/')
    echo "$(echo $results | wc -w) matches: $results"
    ;;

"filename-display"|"fd")
    [ -z "$1" ] && die "'dr edit' needs arguments. See 'dr help search' for help."
    dreamfind "$@"
    echo $args
    ;;

"winnow"|"w"|"setdiff"|"sd")
    #TODO: Add arguments to open results in editor or change to find syntax
    if [[ "$action" == "winnow" || "$action" == "w" ]]
    then commparams="-12"
    else commparams="-3"
    fi

    read toFilter
    dreamfind "$@"
    results=$(comm $commparams <(echo $toFilter | tr ' ' '\n' | sort) <(echo $args | tr ' ' '\n' | sort))
    # since comm needs sorted content, we have to reapply the order changes
    [ $doReverse == 1 ] && results=$(echo "$results" | tac)
    [ $doShuf == 1 ]    && results=$(echo "$results" | shuf)
    echo $results
    ;;

"list-headers"|"lh")
    if [[ "$1" == "-f" ]]; then
        grep -h '^.*:	' *.dre | sed -e 's/^\(.*\):	.*$/\1/' | sort | \
                uniq -c | sort -b -k 1rn -k 2
    else
        grep -h '^.*:	' *.dre | sed -e 's/^\(.*\):	.*$/\1/' | sort | uniq
    fi
    ;;

"header-values"|"hv")
    if [[ "$1" == "-f" || "$2" == "-f" ]]; then
        showfreq=1
        [[ "$1" == "-f" ]] && shift # force header type to $1 in either order
    else
        showfreq=0
    fi
    ensure "! -z \"$1\"" "Please specify a header type, like '`basename $0` header-values Tags'."

    results=$(grep "$1:	" *.dre | cut -d ':' -f 3 | cut -c 2- | \
    #results=$(grep "$1:	" *.dre | awk '{split($0, a, ":"); print a[4],a[3],a[2],a[1]}' | cut -c 2- | \
            sed -e 's/, /\n/g' | sort)
    if [ $showfreq == 1 ]; then
        echo "$results" | uniq -c | sort -b -k 1rn -k 2
    else
        echo "$results" | uniq
    fi
    ;;

"header-replace"|"hr")
    #TODO: Might be wise to do some validation of user's input first; both here and in similar places, what if there's a / or | in the input regex?
    #TODO: Take an automatic backup before beginning?
    if [ "$1" == "-f" ]; then
        echo "WARNING: You are about to run a regex search-and-replace on all"
        echo "specified dreams. Please check the results without -f first!"
        read -p "Do you really want to continue (y/n)? " doCont
        if [ "$doCont" != "y" ]; then
            exit 0
        fi
        doReplace=1
        shift
    else
        doReplace=0
    fi

    header="$1"
    searchpat="$2"
    replpat="$3"
    if [ -z "$4" ]; then
        filenames=$(ls *.dre)
        #TODO: Suggest having this show number of total dreams in dreamdir.
        echo -e "** Running search-and-replace on all dreams. **\n"
    else
        filenames=""
        numChange=0
        while [ ! -z "$4" ]; do
            numChange=$((numChange+1))
            filenames="$filenames $4"
            shift
        done
        #TODO FIXME: Make this not incorrectly pluralize 1 file.
        echo -e "** Running search-and-replace on the $numChange dreams specified. **\n"
    fi

    numAffected=0
    for filename in $filenames
    do
        headerline=$(grep -m 1 "$header:	" "$filename")
        oldtags=$(echo "$headerline" | sed -e "s/$header:	//" | sed -e 's/, /\n/g')
        newtags=$(echo "$oldtags" | sed -re "s/$searchpat/$replpat/g")
        diffs=$(diff -u <(echo "$oldtags") <(echo "$newtags") | grep '^[+-]' | sed '1,2d' | sed -e 's/^/  /')

        if [ -z "$diffs" ]; then
            continue
        fi

        replwith="$header:	$(echo "$newtags" | tr '\n' ',' | sed -e 's/,/, /g' | sed -e 's/, $//')"
        if [ $doReplace == 1 ]; then
            sed -e "s|$headerline|$replwith|" "$filename" > repl.tmp
            rm "$filename"
            mv repl.tmp "$filename"
            echo "$filename modified"
        else
            echo -e "$filename:\n$diffs\n  =$replwith\n"
        fi
        numAffected=$((numAffected+1))
    done
    #TODO FIXME: Make this not incorrectly pluralize 1 file.
    if [ $doReplace == 1 ]; then
        echo "Changed $numAffected files."
    else
        echo "Changes will affect $numAffected files."
    fi

    ;;


"cat"|"c")
    if [ ! -z "$1" ]; then
        # save old stdout, then redirect it to specified file, changing into
        # the directory 'dr' was run from to do the redirect if necessary
        [ $didpush == 1 ] && pushd "$oldpwd"
        ensure "! -f $1" "$1 exists, not overwriting."
        exec 4<&1
        exec 1>"$1" || die "Could not write to specified file, see above."
        [ $didpush == 1 ] && popd
    fi
    for i in *.dre; do
        cat "$i"
        echo -en "\n\n"
    done
    [ ! -z "$1" ] && exec 1<&4 # restore old stdout
    ;;

"validate"|"v")
    validate_dreamdir
    ;;

"stats"|"s")
    stats_display
    ;;

"regenerate-graphs"|"rg")
    scripts/RegeneratePlots.sh ;;

"last-lucid"|"ll")
    "$EDITOR" $(grep -l 'Lucid:	' *.dre | tail -n 1) ;;

"become-lucid"|"bl")
    echo "Nice try." ;;

"version"|"--version"|"v")
    echo "dr version $MYVERSION" ;;

"help"|"--help"|"h"|"-h"|*)
    if [[ "$1" == "search" || "$1" == "s" || "$1" == "edit" || "$1" == "find" ]]; then
        usagemsg_edit
    elif [[ "$1" == "header-replace" || "$1" == "hr" ]]; then
        usagemsg_header_replace
    else
        usagemsg
    fi
    ;;
esac

[[ $didpush == 1 ]] && popd
exit 0
