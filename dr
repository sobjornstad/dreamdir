#!/bin/bash
# %%% dr - Dreamdir utility program
# Copyright (c) 2015-2016 Soren Bjornstad; see LICENSE for details.

##### CONSTANTS #####
# application version
MYVERSION="1.0.2"

# matching pattern for dream files
dreamGlob='[0-9][0-9][0-9][0-9][0-9].dre'

##### DOCUMENTATION / HELP MESSAGES #####
# usagemsg()
# Print the usage/help message and exit.
usagemsg() {
    cat <<USAGEMSG
dr - Dreamdir utility program
Copyright (c) 2015-2016 Soren Bjornstad; see LICENSE for details.

Usage: `basename $0` <action> [<action arguments>]
There are two types of actions, searches and utilities.

                             SEARCHES
Searches display some information about a subset of dreams. They take an
implied 'search expression' after their other arguments. For information
about search expressions, type '`basename $0` help search'.

cat [-f]            :: print all content of matching dreams on stdout; if -f,
                       pass through 'fold -s' to limit line length to 80 chars
dump-headers        :: print headers of matching dreams
edit                :: pass matching dreams as args to \$EDITOR
find                :: show numbers of matching dreams
filename-display    :: print filenames of matching dreams
get-header <header> :: print values of header for matching dreams
header-values [-f] <header> :: show a list of all values used for <header>
                       in matching dream (include frequency if -f)
list-headers [-f]   :: list headers used in at least one matching dream
                       (with frequency if -f specified)
word-count          :: show word count of the specified dreams, not
                       including headers
winnow              :: read filenames from stdin and AND them with
                       the results of another query
xwinnow             :: read filenames from stdin and XOR them with
                       the results of another query

                             UTILITIES
Utilities perform some other action.

help                        :: show this usage message
header-replace              :: regex search-and-replace on headers; type
                               '`basename $0` help header-replace' for info
last-lucid                  :: edit the dream with the highest number that
                               has a Lucid header
new                         :: create a new dream with the next available ID
                               number and open it for editing
regenerate-graphs           :: run scripts/RegeneratePlots.sh to make graphs
stats                       :: display dream statistics
validate                    :: format sanity check: ensure all dreams have
                               IDs and dates and ID numbers are contiguous
version                     :: print version number of this 'dr'

An action can be abbreviated by its initials (e.g., help: h, list-headers: lh).
USAGEMSG
    exit 0
}

# usagemsg_edit()
# Print the help on searching and exit.
usagemsg_edit() {
    cat <<USAGEMSG
                             DR - SEARCHING
`basename $0` <action> [<options>] <expr>

Select dreams matching search expression <expr> and take <action>
(available search actions are listed under 'dr help').

                             SEARCH EXPRESSIONS
A search expression is one or more of the following. If multiple search
expressions are given, their results will be concatenated.
  * a dream number (leading zeroes allowed but not required)
  * a shell globbing pattern for some dream numbers (leading zeroes required)
  * a[ll]          :: select all dreams (same as a quoted '*')
  * b[ack] [<N>]   :: select the dream N positions from the end, inclusive
  * l[ast] [<N>]   :: like 'back', but select all dreams between N and the end
  * g[rep] <regex> :: select all dreams matching ERE <regex> anywhere in the
                      file (whether in headers, notes, or text)
  * t[agged] <header> <hregex> :: select dreams with <header> matching <hregex>
  * r[andom] [<N>] :: select N dreams randomly from your dreamdir, in numerical
                      order (add -s if desired)

N defaults to 1 if not provided.

A search expression may be entirely blank; in this case all dreams are
selected. Options are still parsed (see below).

Globbing patterns used in search expressions should be quoted (e.g., to edit
all dreams, use "dr edit '*'" , not "dr edit *").  They will be expanded either
way, but 'dr' parses large numbers of arguments much more slowly, so the search
will finish faster if you quote the pattern.  Note also that, when the pattern
is quoted, including '.dre' is optional -- that is, '0100[34]' expands to
'01003.dre 01004.dre'.

                             HREGEXES
<hregex>es are Extended Regular Expressions (EREs) that match only within
comma-separated items.  The ^ and $ anchors can be used to match the start and
end of a single item.  For example, with header "Tags: foo, bar baz, foobar":
  REGEX     :: MATCHES
  foo       :: 'foo' & 'foobar'
  bar       :: 'bar' & 'foobar'
  baz       :: 'bar baz'
  az        :: 'bar baz'
  .*baz     :: 'bar baz'
  ^ba.*az   :: 'bar baz'
  ^foobar$  :: 'foobar'
  ^baz$     :: -
  o, ba     :: -
  foo.*baz  :: -
Padding your expression with ^ and $ is often useful; otherwise 'cat' matches
'catalog' and 'duplicate'. If you want to avoid 'catalog' but still get 'cat
food', you can pad with '\\b' (word boundary).

With 'dr find tagged', a dream matches if any comma-separated item matches
the hregex.

With 'dr header-replace', only the specific comma-separated item that matches
is replaced.

                             OPTIONS
The following options may be used with any search expression. They are applied
to the results in this order if several are used:
  -v     :: invert match (show only dreams that do *not* match expression)
  -r     :: reverse the order of returned results
  -s     :: randomize (shuffle) the order of returned results
  -l <N> :: show only the first N results (if N is negative, remove N results
            from the end of the list)

                             EXAMPLES
dr edit 50                    :: edit dream number 50
dr filename-display 006[12]?  :: show the filenames of dreams #610-629
dr edit last 4 890            :: edit the last four dreams and #890
dr dump-headers 20 0[12]01*   :: show headers for dreams #20, #1010-1019,
                                 #2010-2019
dr get-header Tags '*'        :: get a listing of the tags of all your dreams
dr edit -s last 6             :: edit the last six dreams in a random order
dr cat -l 6 grep 'foo|bar'    :: print the first six dreams with a line
                                 containing the substring "foo" or "bar"
dr edit -r grep 'XX' back 20  :: edit the dream 20 from the end, then dreams
                                 containing "XX" in reverse numerical order
dr filename-display random 5  :: list the filenames of five random dreams
dr find tagged People Maud    :: edit dreams in which Maud appeared
dr edit tagged Tags '^cat$'   :: display dreams tagged with 'cat', but not
                                 'caterwaul' or 'dedicate'
dr fd 006[12]? |              :: display filenames for dreams #610-629 that
  dr winnow tagged Tags 'dog'    also have a tag containing 'dog'
dr fd t Tags '^cat$' |        :: show dreams that are not tagged exactly 'cat'
  dr xwinnow grep '\\bcat\\b'      but do use the word 'cat' somewhere else
dr wc                         :: display a word count of all dreams
dr wc -sl 12 all              :: display a word count of 12 random dreams
USAGEMSG
    exit 0
}

usagemsg_header_replace() {
    cat <<USAGEMSG
                             DR - HEADER-REPLACE
`basename $0` header-replace [-f] <header> <find> <replace> <search-expr>

In dreams matching <search-expr>, replace instances of <find> in header
<header> with <replace>.  <header> and <replace> are EREs; <find> is
specifically an hregex (see 'help dr search' for more information).

<find> will not match across commas, but it may match and change several tags
separately.  For example, for the header 'Tags: bar, baz', we could find 'ba'
and replace with 'fo' and obtain 'Tags: for, foz', but a search for 'r, b' will
not match anything.

Each comma-separated value is considered a separate line, so we can search for
'^foobar$' to match only the entire tag 'foobar' and not, say, 'foobarbaz'.

                             PREVIEWING
Without the -f option, dr produces a preview of the changes your search-and-
replace will make.  Typical output looks like this:

    $ dr header-replace Tags "foo" "quux"
                    === Preview of changes to be applied ===
    01223.dre:
      -foo
      +quux
      =Tags:	quux, bar, baz

    Changes will affect 1 file.
    To make these changes, rerun the command with the '-f' option.

One section will be produced for each dream affected.  The first lines
underneath are a diff between the two sets of values.  The last line shows the
new header line that will be substituted in if you accept the changes.

                             RUNNING
After checking over the preview, rerun the command with the -f option to
actually make the changes.  Naturally, this can be quite dangerous with the
wrong regexes (e.g., a replacement of '.' with 'x' will completely trash all
your headers), so it's wise to make a backup first.  You'll also be required to
confirm interactively that you've double-checked the preview.

(NOTE: If the replace command gets interrupted in the middle, it is possible,
though very unlikely, that one of your dreams will have been deleted; you can
check this by seeing if 'dr validate' fails with a missing ID number.  If this
does occur you will find the content in the file 'repl.tmp' in your dreamdir.)
USAGEMSG
}

##### UTILITY FUNCTIONS #####
# ensure()
# Make sure a condition necessary for script execution is true.
#
# Arguments:
#     $1 - an argument to `test`
#     $2 - a message to display if the test fails
#     $3 - (optional, default 1) exit status to return if the test fails
# State change & return:
#     If the test evaluates non-zero, the script prints $2 and exits with
#     status $3 (or 1). Else, control returns to the caller.
ensure() {
    eval "test $1"
    if [ $? -ne 0 ]
    then
        if [ -z "$3" ]; then
            local exitval=1
        else
            local exitval=$3
        fi
        echo -e "$2"
        exit $exitval
    else
        return 0
    fi
}

# die()
# Unconditionally exit the shell with status 1 after printing the given error.
#
# Arguments:
#     $1 - Message to complain with.
die() {
    echo -e "$1"
    exit 1
}

# don't display the directory stack on push/pop
pushd () {
    command pushd "$@" > /dev/null
}
popd () {
    command popd "$@" > /dev/null
}

# numerize()
# Display some string in singular or plural as appropriate.
#
# Arguments:
# $1 - the number to condition the singular/plural status on
# $2 - the singular form
# $3 - the plural form (optional; if not provided, defaults to singular + 's')
#
# Example:
# $ echo "I think there $(numerize $n "is" "are") $n $(numerize $n "foo") here."
# I think there is 1 foo here.
# I think there are 2 foos here.
numerize() {
    ensure "! -z \"$1\"" "Invalid arguments given to numerize()"
    ensure "! -z \"$2\"" "Invalid arguments given to numerize()"
    local num=$1
    local singular=$2
    if [ -z "$3" ]; then
        local plural="$singular"s
    else
        local plural=$3
    fi

    if [ $num -ne 1 ]; then
        echo "$plural"
    else
        echo "$singular"
    fi
}

##### COMPLICATED ROUTINES #####
# dreamfind()
# Parse a search expression. The filenames of matching dreams are placed in
# the variable $args.
dreamfind() {
    # Parse optional arguments to edit.
    df_doReverse=0    # global because a user that has to sort the results
    df_doShuf=0       # for further processing has to reapply these filters
    local limit=0
    local invert=0
    OPTIND=0  # if loop doesn't run at all, we need to make sure it's reset
    while getopts rsl:v opt; do
        case $opt in
        r)
            df_doReverse=1 ;;
        s)
            df_doShuf=1 ;;
        l)
            limit="$OPTARG" ;;
        v)
            invert=1 ;;
        esac
    done
    shift $((OPTIND-1))

    # No arguments is equivalent to "all".
    if [ -z "$1" ]; then
        # http://stackoverflow.com/questions/13762370/
        # assigning-to-a-positional-parameter
        set -- "all"
    fi

    # Otherwise, compile a list of all the dreams we've specified.
    args=""
    local newargs=""
    local howMany=0
    while [ ! -z "$1" ]; do
        if [[ $1 =~ ^[0-9][0-9]*$ ]]
        then
            let local num=10#$1  # in case user uses leading zeroes
            printf -v newargs '%05d.dre' "$num"
        else case "$1" in
        "last"|"back"|"l"|"b")
            howMany="$2"
            [ -z "$2" ] && howMany=1
            newargs=$(ls $dreamGlob | tail -n $howMany)
            if [[ "$1" == "back" || "$1" == "b" ]]; then
                newargs=$(echo "$newargs" | head -n 1)
            fi
            [ ! -z "$2" ] && shift # automatic shift handles only one arg
            ;;
        
        "grep"|"g")
            ensure "! -z \"$2\"" "'grep' needs a pattern. (See 'dr help search' for help.)"
            newargs=$(grep -El "$2" $dreamGlob)
            shift # automatic shift handles only one arg
            ;;

        "random"|"r")
            howMany=$2
            [ -z "$howMany" ] && howMany=1
            newargs=$(ls $dreamGlob | shuf | head -n $howMany | sort)
            ;;

        "all"|"a")
            newargs=$dreamGlob
            ;;

        "tagged"|"t")
            local usage="Usage: dr $action tagged <header regex> <value regex>"
            ensure "! -z \"$2\"" "$usage"
            ensure "! -z \"$3\"" "$usage"
            # The idea here is to replace the delimiters with '@@@@@' (which we
            # can fairly safely assume will not show up in a tag), then change
            # the user's regex to match '@@@@@' as BOL/EOL and not cross it
            # with '.'.
            local header="$2"
            local pattern=$(echo "$3" | sed -e 's/[$^]/@@@@@/' | sed -e 's/\$/[$@]/' | sed -e 's/\./[^@]/')
            newargs=$(grep -m 1 "$header:	" $dreamGlob | sed -e "s/$header:	/@@@@@/" | sed -e 's/, /@@@@@/g' | sed -e 's/$/@@@@@/' | grep -E "$pattern" | sed -e 's/\([0-9]\{5\}\.dre\):.*/\1/')
            shift; shift
            ;;

        *) # filename glob
            if [[ $(echo "$1" | grep ".dre") ]]; then
                newargs="$1"
            else
                newargs="$1.dre"
            fi
        esac
        fi  # regex matches

        # Add args parsed to the complete list and proceed. Note that if a type
        # of expression has arguments, it's responsible for shifting those away
        # before it finishes.
        args="$args $newargs"
        shift
    done

    # apply option flags
    args=$(echo $args | cat -) # looks like a no-op, but it expands globs
    if [ $invert -eq 1 ]; then
        args=$(comm -3 <(ls $dreamGlob | tr ' ' '\n' | sort) <(echo $args | tr ' ' '\n' | sort))
    fi
    [ $df_doReverse -eq 1 ] && args=$(echo $args | tr ' ' '\n' | tac)
    [ $df_doShuf -eq 1 ]    && args=$(echo $args | tr ' ' '\n' | shuf)
    [ $limit -ne 0 ]     && args=$(echo $args | tr ' ' '\n' | head -n $limit)

    # sanity check
    [ -z "$args" ] && die "No results."
    for i in $args
    do
        error="Matched nonexistent file '$i'; please check your search terms and try again.\n(Type 'dr help search' for help.)"
        ensure "-f \"$i\"" "$error"
    done
}

# validate_dreamdir()
# Check to see if our dreamdir's format is okay. Extracted from the main case
# statement purely because it's long and makes the script harder to read.
validate_dreamdir() {
    # set up temp file for checking id and date headers
    local tempfile="/tmp/dreamgrep" # contains list of dream files
    ensure "! -e $tempfile" "Please check & remove existing temp file $tempfile and try again."
    ls $dreamGlob | sort > "$tempfile"

    # check for id problems
    local checkFailedFor=$(grep -l 'Id:	[0-9]\{5\}' $dreamGlob | sort | diff - "$tempfile")
    if [ $? == 0 ]; then
        echo "ID value check...OK"
    else
        echo "ID value check...FAIL"
        echo "The files listed in the following diff have missing or incomplete"
        echo "Id headers:"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi

    # check for date problems (similar -- consider a function)
    checkFailedFor=$(grep -l 'Date:	[12][901][0-9]\{2\}-[01][0-9]-[0123][0-9]' $dreamGlob | sort | diff - "$tempfile")
    if [ $? == 0 ]; then
        echo "Date check...OK"
    else
        echo "Date check...FAIL"
        echo "The files listed in the following diff have missing or invalid"
        echo "Date headers, or represent implausible or impossible dates."
        echo "(Note: dates must be in YYYY-MM-DD format.)"
        echo "$checkFailedFor"
        rm "$tempfile"
        exit 1
    fi
    rm "$tempfile"

    # check for ID continuity
    # works with Python 2 & 3 -- check dual compatibility after changes
    python <<PYTH_ID_CHECK
import os, sys
listing = sorted(os.listdir('.'))
listing = filter(lambda i: i.endswith('.dre'), listing)
nums = []
for i in listing:
    try:
        nums.append(int(i))
    except ValueError:
        # not a dream file, but auxiliary of some kind
        continue

lastnum = 0
for i in nums:
    if i != lastnum+1:
        print("ID continuity check...FAIL")
        print("Failure was on ID %i, not continuous with previous ID %i." % (
              i, lastnum))
        sys.exit(1)
    else:
        lastnum = i
print("ID continuity check...OK")
sys.exit(0)
PYTH_ID_CHECK
    if [ $? != 0 ]; then
        exit 1
    fi

    echo "All tests succeeded."
}

# stats_display()
# Calculate and display textual statistics.
stats_display() {
    echo "Crunching the latest numbers for you, just a moment..."
    local colOn='[1;34m'
    local colOff='[0m'

    local today=$(date '+%Y-%m-%d')
    local filenamesToday=$(grep -l "Date:	$today" $dreamGlob)
    if [ ! -z "$filenamesToday" ]; then
        local dreamsToday=$(echo $filenamesToday | sed -e 's/\.dre'//g | sed -e 's/ 0*/ /g' | sed -e 's/^0*//') # NOT very clean.
        local numDreamsToday=$(echo $dreamsToday | wc -w)
        local dreamsTodayDisp=$(echo $dreamsToday | sed -e 's/ /, /g')
        local lucidsToday=$(grep 'Lucid:	' $filenamesToday | wc -l)
        local wordCountToday=$(wc -w $filenamesToday | tail -n 1 | sed -e 's/^ *//' | cut -d ' ' -f 1)
        if [ -f $wordCountToday ]; then
            # there was only one dream and no "total" line, so we pulled out the wrong thing
            wordCountToday=$(wc -w $filenamesToday | cut -d ' ' -f 1)
        fi
    fi

    local numDreams=$(ls $dreamGlob | wc -l)
    local wordCount=$(wc $dreamGlob -w | tail -n 1 | cut -d ' ' -f 2)
    local avgWordCount=$((wordCount / numDreams))
    local dateStats=$(python2 <<PYTH_DATEFREQ
# OUTPUT FORMAT:
# <number of dates recorded> <earliest date> <latest date> <date with most dreams> <how many that was>
import scripts.ddirparse as dp
dp.setDreamdir("$PWD")
dateattrs = dp.getAttribForAllDreams('Date')
dates = [i.split('\t')[1] for i in dateattrs.values()]
freqs = {}
for date in dates:
    freqs[date] = freqs.get(date, 0) + 1
keyList = freqs.keys()
print len(keyList),
print min(keyList),
print max(keyList),
# create list of keys sorted by the order of their values, min to max
byFreq = sorted(keyList, cmp=lambda a,b: cmp(freqs[a],freqs[b]))
print byFreq[-1],       # most number of dreams
print freqs[byFreq[-1]] # how many?
PYTH_DATEFREQ
)
    local mostWordsDay=$(python2 <<PYTH_MOSTWORDS
# Getting acceptable performance here requires unfolding some possible
# functions and abstractions into this (nevertheless simple enough) loop.
# TODO: This should be a function in scripts.ddirparse, I can think of tons of
# other good things to do with this, like graphing and printing a table.
import scripts.ddirparse as dp
dp.setDreamdir("$PWD")
wcs = {}
for f in dp.allDreamfiles():
    date = None
    counting = False
    for line in f:
        textline = line.strip()
        if counting:
            wcs[date] += len(textline.split())
        else:
            if textline.startswith('Date:\t'):
                date = textline.split(':\t')[1].strip()
            elif not textline:
                # end of headers, start counter
                counting = True
                if date not in wcs:
                    wcs[date] = 0
# create list of keys sorted by the order of their values, max to min
wcOrder = sorted(wcs.keys(), cmp=lambda a,b: cmp(wcs[b],wcs[a]))
print wcOrder[0], wcs[wcOrder[0]], # # of dreams, date of it
print len(dp.getDreamsTagged('Date', wcOrder[0])) # how many dreams
PYTH_MOSTWORDS
)
    local datesRecorded=$(echo "$dateStats" | cut -d ' ' -f 1)
    local avgDreamsPerDay=$(echo "scale=2; $numDreams / $datesRecorded" | bc -q)
    local avgWordCountDay=$(echo "$avgDreamsPerDay * $avgWordCount" | bc -q)
    local earliestDate=$(echo "$dateStats" | cut -d ' ' -f 2)
    local latestDate=$(echo "$dateStats" | cut -d ' ' -f 3)
    local mostDreamsDate=$(echo "$dateStats" | cut -d ' ' -f 4)
    local numMostDreams=$(echo "$dateStats" | cut -d ' ' -f 5)

    local mostWordsOnDay=$(echo "$mostWordsDay" | cut -d ' ' -f 1)
    local mostWords=$(echo "$mostWordsDay" | cut -d ' ' -f 2)
    local dreamsInMostWordsDay=$(echo "$mostWordsDay" | cut -d ' ' -f 3)
    local mostWordsDream=$(wc -w $dreamGlob | sort -n | sed -e '$ d' | tail -n 1)
    local mostWordsDreamNum=$(echo "$mostWordsDream" | sed -e 's/^ *[0-9]\+ 0*\([0-9]\+\).dre$/\1/')
    local mostWordsDreamCount=$(echo "$mostWordsDream" | sed -e 's/^ *\([0-9]\+\).*/\1/')

    local lucidFilenames=$(grep -l 'Lucid:	' $dreamGlob)
    local numLucids=$(echo $lucidFilenames | wc -w) # -w: $() collapses \n to space
    local percentLucid=$(echo "scale=2; 100 * $numLucids / $numDreams" | bc -q)
    local totalLucidWordCount=$(wc -w $lucidFilenames | tail -n 1 | cut -d ' ' -f 2)
    local avgLucidWordCount=$((totalLucidWordCount / numLucids))
    local percentLucidWordCount=$(echo "scale=2; 100 * $totalLucidWordCount / $wordCount" | bc -q)
    local daysRecordedLds=$(python2 <<PYTH_DAYS_LDS
# Output format: <days with recorded LDs>
import scripts.ddirparse as dp
dp.setDreamdir("$PWD")
lucids = dp.getDreamsTagged('Lucid', '')
allDates = dp.getAttribForAllDreams('Date')
allDates = {k: v.split('\t')[1] for k,v in allDates.iteritems()}
# Use a dictionary to make future expansion to frequency, etc., easier
lucidDays = {}
for i in lucids:
    lucidDays[allDates[i]] = lucidDays.get(allDates[i], 0) + 1
print len(lucidDays)
PYTH_DAYS_LDS
)
    local percentDaysRecordedLds=$(echo "scale=2; 100 * $daysRecordedLds / $datesRecorded" | bc -q)

# Consider, inserting commas into a number:
# echo "$number" | rev | sed 's/\([0-9][0-9][0-9]\)\([0-9]\)/\1,\2/g' | rev

echo -e "${colOn}Today$colOff"
echo -e "Today: $today"
if [ -z "$filenamesToday" ]; then
    echo -e "No dreams recorded today.\n"
else
    echo -e "Dreams recorded today: $numDreamsToday ($dreamsTodayDisp)"
    echo -e "Lucid dreams recorded today: $lucidsToday"
    echo -e "Total word count today: $wordCountToday\n"
fi
cat <<STATS_DISP
${colOn}Recall and recording$colOff
Total dreams: $numDreams
Days with recorded dreams: $datesRecorded
Average dreams per recorded day: $avgDreamsPerDay
Date range: $earliestDate – $latestDate
Day with most dreams: $mostDreamsDate ($numMostDreams)
Total word count: $wordCount
Average words per dream: $avgWordCount
Day with highest word count: $mostWordsOnDay ($mostWords words over $dreamsInMostWordsDay dreams)
Single dream with highest word count: #$mostWordsDreamNum ($mostWordsDreamCount words)

${colOn}Lucidity$colOff
Total lucid dreams: $numLucids
Percentage lucid: $percentLucid%
Days with recorded LDs: $daysRecordedLds
Percentage recorded days with at least one LD: $percentDaysRecordedLds%
Total lucid word count: $totalLucidWordCount
Average words per lucid dream: $avgLucidWordCount
Percentage of words in lucid dreams: $percentLucidWordCount%

${colOn}Table summary${colOff}
		Total	Avg/Day	Max/Day	Today
# of dreams	$numDreams	$avgDreamsPerDay	$numMostDreams	$numDreamsToday
Word count	$wordCount	$avgWordCountDay	$mostWords	$wordCountToday

See also 'dr list-headers -f' and 'dr header-values -f [header]'.
STATS_DISP
}


##### MAIN SCRIPT #####
# If DREAMDIR environment variable is set and we're not already in $DREAMDIR,
# change directory into it until the end of the script.
didpush=0
oldpwd="$PWD" # if we need to know where the user is running the script from
if [[ ! -z "$DREAMDIR" && "$PWD" != "$DREAMDIR" && ! -f ".dreamdir" ]]; then
    didpush=1
    pushd "$DREAMDIR"
    if [[ $? != 0 ]]; then
        echo "ERROR: The current directory is not a dreamdir and the DREAMDIR"
        echo "environment variable is set to an invalid directory"
        echo "($DREAMDIR). Exiting."
        exit 1
    fi
fi

# Confirm that we've ended up in a dreamdir.
error="Please run this script from a dreamdir, or set the environment\n"\
"variable \$DREAMDIR to the path to your dreamdir."
ensure '-f .dreamdir' "$error"

# Figure out what action we're going to do and jump to appropriate code.
[ -z "$1" ] && usagemsg
action="$1"
shift # arguments to actions start at $1

case "$action" in
"new"|"n")
    oldUmask=$(umask)
    umask 0177 # dreams default to 600 for basic privacy
    today=$(date '+%Y-%m-%d')
    lastNum=$(ls $dreamGlob | sort | tail -n 1 | cut -c 1-5)
    ensure "-f $lastNum.dre" "Unable to correctly find last dream number. Please ensure no non-dream files in the dreamdir end with '.dre'. (Pulled '$lastNum'.)"
    let newNum=10#$lastNum+1
    printf -v newNum '%05d' "$newNum"

    # http://unix.stackexchange.com/questions/88490/how-do-you-use-output-redirection-in-combination-with-here-documents-and-cat
    ed <<NEWDREAM >/dev/null 2>&1
i
Id:	$newNum
Date:	$today
Time:	
Tags:	


.
w $newNum.dre
w /tmp/$newNum.dre
q
NEWDREAM

    if [ "$EDITOR" == "vim" ]; then
        # use vim's option to place the cursor on the last line
        vim "$newNum.dre" +
    else
        "$EDITOR" "$newNum.dre"
    fi
    diff "/tmp/$newNum.dre" "$newNum.dre" > /dev/null 2>&1
    if [ $? == 0 ]; then
        echo "Deleting unmodified dream file."
        rm "$newNum.dre"
    fi
    rm "/tmp/$newNum.dre"
    umask $oldUmask
    ;;

"edit"|"e")
    dreamfind "$@"
    $EDITOR $args
    ;;

"find"|"f")
    dreamfind "$@"
    # remove leading zeroes and '.dre' for display, add separator commas
    results="$(echo $args | sed -e 's/\(^\| \)00*/\1/g' | sed -e 's/\.dre/,/g')"
    echo -e "$(echo $results | wc -w) matches: [$results\b]"
    ;;

"filename-display"|"fd")
    dreamfind "$@"
    echo $args
    ;;

"winnow"|"w"|"xwinnow"|"x")
    #TODO: Add arguments to open results in editor or change to find syntax
    if [[ "$action" == "winnow" || "$action" == "w" ]]
    then commparams="-12"
    else commparams="-3"
    fi

    read toFilter
    dreamfind "$@"
    results=$(comm $commparams <(echo $toFilter | tr ' ' '\n' | sort) <(echo $args | tr ' ' '\n' | sort))
    # since comm needs sorted content, we have to reapply the order changes
    [ $df_doReverse == 1 ] && results=$(echo "$results" | tac)
    [ $df_doShuf == 1 ]    && results=$(echo "$results" | shuf)
    echo $results
    ;;

"get-header"|"gh")
    #TODO: Possibility of formatting options (filename or number, remove
    #leading 0's, include header name)
    usageMsg="Usage: `basename $0` get-header <header> <search-expr>"
    ensure "! -z \"$1\"" "$usageMsg"
    ensure "! -z \"$2\"" "$usageMsg"
    getHeader=$1
    shift
    dreamfind "$@"
    grep "$getHeader:	" $args | sed -e "s/$getHeader:	\(.*\)/\1/" | sed -e 's/^00*\([0-9]\+\).dre:/\1: /'
    ;;

"dump-headers"|"dh")
    dreamfind "$@"
    for i in $args; do
        [ ! -f "$i" ] && echo "File $i not found."
        awk '{ if(!$0) exit; print $0; }' < "$i"
        echo ""
    done
    ;;

"cat"|"c")
    if [ "$1" == "-f" ]; then
        printCommand="fold -s"
        shift
    else
        printCommand="cat"
    fi

    dreamfind "$@"
    for i in $args; do
        $printCommand "$i"
        echo -en "\n\n"
    done
    ;;

"list-headers"|"lh")
    if [ "$1" == "-f" ]; then
        showFreq=1
        shift
    else
        showFreq=0
    fi
    dreamfind "$@"
    results=$(grep -h '^.*:	' $args | sed -e 's/^\(.*\):	.*$/\1/' | sort)
    if [ $showFreq == 1 ]; then
        echo "$results" | uniq -c | sort -b -k 1rn -k 2
    else
        echo "$results" | uniq
    fi
    ;;

"header-values"|"hv")
    if [ "$1" == "-f" ]; then
        showfreq=1
        shift
    else
        showfreq=0
    fi
    ensure "! -z \"$1\"" \
        "Please specify a header type, like '`basename $0` header-values Tags'."
    header="$1"
    shift
    dreamfind "$@"

    results=$(grep "$header:	" $args | sed -e 's/.*:	//' | sed -e 's/, /\n/g' | sort)
    if [ $showfreq == 1 ]; then
        echo "$results" | uniq -c | sort -b -k 1rn -k 2
    else
        echo "$results" | uniq
    fi
    ;;

"header-replace"|"hr")
    usageMsg="Usage: `basename $0` header-replace [-f] <header> <search> <replace> <search-expr>\nType 'dr help header-replace' for details."
    ensure "! -z \"$1\"" "$usageMsg"
    ensure "! -z \"$2\"" "$usageMsg"
    ensure "! -z \"$3\"" "$usageMsg"
    [[ "$2" =~ "@" || "$3" =~ "@" ]] && \
        die "Sorry, at-signs (@) are not valid in search/replace regexes."

    if [ "$1" == "-f" ]; then
        doChange=1
        shift
    else
        doChange=0
    fi

    header="$1"
    searchpat="$2"
    replpat="$3"
    shift; shift; shift

    # Since the replace loop is rather expensive, compile a list of dreams that
    # both match our search-expr and include the <search> hregex, and look only
    # at those.
    dreamfind "$@"
    affectOnlyDreams="$args"
    dreamfind tagged "$header" "$searchpat"
    args=$(comm -12 <(echo $affectOnlyDreams | tr ' ' '\n') \
                    <(echo $args | tr ' ' '\n'))

    # If we're actually making changes, confirm that we really want to.
    if [ $doChange == 1 ]; then
        numToChange=$(echo "$args" | wc -w)
        echo "You are about to apply a search-and-replace that will affect" \
        "$numToChange $(numerize $numToChange dream)."
        if [ $numToChange -ge 50 ]; then
            echo -e "\e[1;31mThat looks like quite a few dreams.\e[0m"
        fi
        echo "If this doesn't sound right, please check the results without -f first!"
        read -p "Do you wish to continue (y/n)? " doCont
        if [ "$doCont" != "y" ]; then
            exit 0
        fi
        doReplace=1
        shift
    else
        echo "                    === Preview of changes to be applied ==="
        doReplace=0
    fi

    numAffected=0
    for filename in $args
    do
        headerline=$(grep -m 1 "$header:	" "$filename")
        oldtags=$(echo "$headerline" | sed -e "s/$header:	//" | sed -e 's/, /\n/g')
        newtags=$(echo "$oldtags" | sed -re "s@$searchpat@$replpat@g")
        diffs=$(diff -u <(echo "$oldtags") <(echo "$newtags") | grep '^[+-]' | sed '1,2d' | sed -e 's/^/  /')

        if [ -z "$diffs" ]; then
            continue
        fi

        replwith="$header:	$(echo "$newtags" | tr '\n' ',' | sed -e 's/,/, /g' | sed -e 's/, $//')"
        if [ $doReplace == 1 ]; then
            sed -e "s@$headerline@$replwith@" "$filename" > repl.tmp
            rm "$filename"
            mv repl.tmp "$filename"
            echo "$filename modified"
        else
            echo -e "$filename:\n$diffs\n  =$replwith\n"
        fi
        numAffected=$((numAffected+1))
    done
    if [ $doReplace == 1 ]; then
        echo "Changed $numAffected $(numerize $numAffected file)."
    else
        echo "Changes will affect $numAffected $(numerize $numAffected file)."
        echo "To make these changes, rerun the command with the '-f' option."
    fi

    ;;

"validate"|"v")
    validate_dreamdir
    ;;

"word-count"|"wc")
    dreamfind "$@"
    if [ -x "scripts/bin/drwc" ]; then
        scripts/bin/drwc -p $args
    else
        python2 <<WC_END
import scripts.ddirparse as dp
print dp.getCount("$args".split(' '), asPrettyString=True)
WC_END
    fi
    ;;

"stats"|"s")
    stats_display
    ;;

"regenerate-graphs"|"rg")
    scripts/RegeneratePlots.sh ;;

"last-lucid"|"ll")
    "$EDITOR" $(grep -l 'Lucid:	' $dreamGlob | tail -n 1) ;;

"become-lucid"|"bl")
    echo "Nice try." ;;

"version"|"--version"|"v")
    echo "dr version $MYVERSION" ;;

"help"|"--help"|"h"|"-h"|*)
    if [[ "$1" == "search" || "$1" == "s" || "$1" == "edit" || "$1" == "find" ]]; then
        usagemsg_edit
    elif [[ "$1" == "header-replace" || "$1" == "hr" ]]; then
        usagemsg_header_replace
    else
        usagemsg
    fi
    ;;
esac

[[ $didpush == 1 ]] && popd
exit 0
